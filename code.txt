[PROJECT STRUCTURE]
[FILE: marinette/assets/i18n/en.json]
{
  "app_name": "Beauty Recommendations",
  "take_photo": "Take Photo",
  "choose_from_gallery": "Choose from Gallery",
  "analyzing": "Analyzing your photo...",
  "recommendations": "Recommendations",
  "face_shape": "Face Shape",
  "color_type": "Color Type",
  "makeup_recommendations": "Makeup",
  "hairstyle_recommendations": "Hairstyle",
  "skincare_recommendations": "Skincare",
  "error_no_face": "No face detected. Please try again.",
  "error_multiple_faces": "Multiple faces detected. Please use a photo with one face.",
  "error_camera": "Camera error. Please try again.",
  "error": "Error",
  "info": "Information",
  "share_coming_soon": "Sharing feature coming soon!",
  "analysis_failed": "Failed to analyze photo. Please try again.",
  "welcome_message": "Take or choose a photo to get personalized beauty recommendations",
  "history": "History",
  "no_history": "You don't have any saved results yet",
  "confirm_delete": "Confirm Deletion",
  "delete_result_confirmation": "Are you sure you want to delete this result?",
  "cancel": "Cancel",
  "delete": "Delete",
  "error_saving_result": "Error saving result",
  "error_loading_result": "Error loading result",
  "error_loading_results": "Error loading results",
  "error_deleting_result": "Error deleting result",
  "error_sharing": "Error sharing results",

  "face_shape_oval": "Oval",
  "face_shape_round": "Round",
  "face_shape_square": "Square",
  "face_shape_heart": "Heart-shaped",
  "face_shape_diamond": "Diamond",
  "face_shape_rectangle": "Rectangle",

  "color_type_spring": "Spring",
  "color_type_summer": "Summer",
  "color_type_autumn": "Autumn",
  "color_type_winter": "Winter",

  "season_winter": "In winter, pay special attention to moisturizing and protecting your skin from the cold. Use more nourishing creams and protective lip balms.",
  "season_spring": "In spring, focus on skin renewal after winter. Add exfoliating products and antioxidants to your care routine.",
  "season_summer": "In summer, sun protection is the most important element of care. Use light textures and don't forget about hydration.",
  "season_autumn": "In autumn, skin needs special protection and restoration. Pay attention to products with vitamins and antioxidants.",

  "makeup_shape_oval": "Enhance natural proportions with light contouring",
  "makeup_shape_oval_2": "Apply blush diagonally upward for additional lifting",
  "makeup_shape_oval_3": "Experiment with different techniques - your face shape is universal",
  "makeup_shape_oval_4": "Emphasize eyes or lips according to your preference",
  "makeup_shape_oval_5": "Use highlighter on cheekbones to enhance natural relief",

  "makeup_shape_round": "Use contouring on the sides of the face for elongation",
  "makeup_shape_round_2": "Apply blush at an upward angle to elongate the shape",
  "makeup_shape_round_3": "Create clear angles when applying foundation in the jaw area",
  "makeup_shape_round_4": "Emphasize cheekbones with highlighter",
  "makeup_shape_round_5": "Use oval contouring technique for nose",
  
  "makeup_shape_square": "Soften face angles with blended contouring",
  "makeup_shape_square_2": "Apply blush in circular motions to soften features",
  "makeup_shape_square_3": "Avoid sharp lines when applying makeup",
  "makeup_shape_square_4": "Add light-reflecting particles in the cheekbone area",
  "makeup_shape_square_5": "Use soft pastel shades for eyes",
  
  "makeup_shape_heart": "Emphasize cheekbones to balance wider forehead",
  "makeup_shape_heart_2": "Use highlighter on chin for visual elongation",
  "makeup_shape_heart_3": "Darken outer corners of forehead for balance",
  "makeup_shape_heart_4": "Apply blush closer to the center of cheeks",
  "makeup_shape_heart_5": "Accent lower part of face with light shades",
  
  "makeup_shape_diamond": "Focus contouring on temples and chin",
  "makeup_shape_diamond_2": "Apply blush horizontally to soften sharp angles",
  "makeup_shape_diamond_3": "Emphasize face center with light shades",
  "makeup_shape_diamond_4": "Use soft transitions when blending",
  "makeup_shape_diamond_5": "Add volume to lower face with light textures",
  
  "makeup_shape_rectangle": "Create soft transitions with contouring",
  "makeup_shape_rectangle_2": "Use blush to add roundness",
  "makeup_shape_rectangle_3": "Emphasize cheekbones for proportion balance",
  "makeup_shape_rectangle_4": "Add light accents in the central face area",
  "makeup_shape_rectangle_5": "Avoid vertical lines when applying makeup",
  
  "makeup_color_spring": "Choose warm, bright lipstick shades: coral, peach, warm pink",
  "makeup_color_spring_2": "Use golden and peach blush",
  "makeup_color_spring_3": "Bronze, gold, and warm brown eyeshadows will suit you",
  "makeup_color_spring_4": "Experiment with terracotta lip shades",
  "makeup_color_spring_5": "Use warm bronzer shades",

  "makeup_color_summer": "Choose cool, muted lipstick shades: pink, raspberry",
  "makeup_color_summer_2": "Use cool pink and lavender blush",
  "makeup_color_summer_3": "Silver, grey, and cool brown tones for eyes are ideal",
  "makeup_color_summer_4": "Avoid too bright and warm shades",
  "makeup_color_summer_5": "Prefer pastel tones",

  "makeup_color_autumn": "Choose warm, earthy lipstick shades: terracotta, copper",
  "makeup_color_autumn_2": "Use warm brown and terracotta blush",
  "makeup_color_autumn_3": "Green and golden-brown eyeshadows will suit you",
  "makeup_color_autumn_4": "Experiment with rich autumn colors",
  "makeup_color_autumn_5": "Add golden shimmer for glow",

  "makeup_color_winter": "Choose bright, contrasting lipstick shades: red, fuchsia",
  "makeup_color_winter_2": "Use cool pink and berry blush",
  "makeup_color_winter_3": "Smokey, blue, and silver eyeshadows will suit you",
  "makeup_color_winter_4": "Experiment with saturated colors",
  "makeup_color_winter_5": "Use contrasting combinations",

  "haircolor_spring": "Golden blonde shades will emphasize natural brightness",
  "haircolor_spring_2": "Honey and caramel tones will suit perfectly",
  "haircolor_spring_3": "Experiment with warm red shades",

  "haircolor_summer": "Choose cool platinum and ashy shades",
  "haircolor_summer_2": "Pearl blonde will emphasize your appearance",
  "haircolor_summer_3": "Try pastel tones",

  "haircolor_autumn": "Choose rich chestnut and copper shades",
  "haircolor_autumn_2": "Golden-brown tones will enhance natural beauty",
  "haircolor_autumn_3": "Experiment with warm red tones",

  "haircolor_winter": "Choose contrasting colors - black or platinum blonde",
  "haircolor_winter_2": "Cool dark shades will emphasize your appearance",
  "haircolor_winter_3": "Try bluish-black tones",

  "hairstyle_oval": "Most hairstyles suit you thanks to your proportional face shape",
  "hairstyle_oval_2": "Try long hair with light waves for a romantic look",
  "hairstyle_oval_3": "Medium length with graduation will emphasize facial features",
  "hairstyle_oval_4": "You can experiment with any type of bangs",
  "hairstyle_oval_5": "Both straight and curly hairstyles will work well",
  
  "hairstyle_round": "Choose hairstyles that add height and elongate the face",
  "hairstyle_round_2": "Avoid too voluminous styles on the sides",
  "hairstyle_round_3": "Asymmetrical cuts will help elongate the face",
  "hairstyle_round_4": "Long hair with textured ends will create the desired effect",
  "hairstyle_round_5": "Side-swept bangs will help make face appear more refined",
  
  "hairstyle_square": "Choose soft, wavy styles to soften features",
  "hairstyle_square_2": "Avoid straight hair with sharp lines",
  "hairstyle_square_3": "Layered cuts will add softness",
  "hairstyle_square_4": "Length below chin will soften jawline",
  "hairstyle_square_5": "Light curls around face will create romantic look",
  
  "hairstyle_heart": "Choose styles with volume at bottom for balance",
  "hairstyle_heart_2": "Avoid too much volume at top",
  "hairstyle_heart_3": "Medium length with soft layers is ideal",
  "hairstyle_heart_4": "Side parts help balance features",
  "hairstyle_heart_5": "Long side bangs will soften forehead line",
  
  "hairstyle_diamond": "Choose styles with volume in temple area",
  "hairstyle_diamond_2": "Experiment with layered cuts",
  "hairstyle_diamond_3": "Shoulder length or longer is most flattering",
  "hairstyle_diamond_4": "Avoid styles too close to head",
  "hairstyle_diamond_5": "Soft medium-length waves emphasize your face shape",
  
  "hairstyle_rectangle": "Choose layered cuts to add volume",
  "hairstyle_rectangle_2": "Add side volume for proportion balance",
  "hairstyle_rectangle_3": "Avoid too long straight hair",
  "hairstyle_rectangle_4": "Bangs help visually shorten face length",
  "hairstyle_rectangle_5": "Cascade cuts create needed volume",
  
  "skincare_recommendation_1": "Always use sunscreen daily",
  "skincare_recommendation_2": "Cleanse your skin twice a day with a gentle cleanser",
  "skincare_recommendation_3": "Don't forget about skin hydration",
  "skincare_recommendation_4": "Regular exfoliation and peeling",
  "skincare_recommendation_5": "Use serums with active ingredients",
  
  "skincare_spring": "Use light texture products",
  "skincare_spring_2": "Pay attention to vitamin C products",
  "skincare_spring_3": "Add antioxidants to your routine",
  "skincare_spring_4": "Protect from pigmentation with SPF 30-50",
  "skincare_spring_5": "Choose calming masks for sensitive skin",
  
  "skincare_summer": "Use non-comedogenic products",
  "skincare_summer_2": "Moisturize with light gel textures",
  "skincare_summer_3": "Protect from sun with SPF 50+",
  "skincare_summer_4": "Add niacinamide to your routine",
  "skincare_summer_5": "Regular use of calming masks",
  
  "skincare_autumn": "Choose rich-textured nourishing creams",
  "skincare_autumn_2": "Use oils for additional nourishment",
  "skincare_autumn_3": "Protect from sun with SPF 30+",
  "skincare_autumn_4": "Pay attention to retinol products",
  "skincare_autumn_5": "Regular use of moisturizing masks",
  
  "skincare_winter": "Use creams with rich texture",
  "skincare_winter_2": "Add peptides and ceramides to your routine",
  "skincare_winter_3": "Protect from sun with SPF 50+",
  "skincare_winter_4": "Pay attention to hyaluronic acid products",
  "skincare_winter_5": "Regular nourishing masks",

  "personalized_makeup_base": "For your appearance type, it's especially important to: ",
  "personalized_makeup_oval": "emphasize the natural harmony of facial features",
  "personalized_makeup_round": "create visual vertical lines",
  "personalized_makeup_square": "soften facial angles",
  "personalized_makeup_heart": "balance upper and lower parts of the face",
  "personalized_makeup_diamond": "accent the center of the face",
  "personalized_makeup_rectangle": "create harmonious proportions",

  "personalized_makeup_spring": "Use warm, bright shades for a fresh look",
  "personalized_makeup_summer": "Choose soft, pastel tones for natural makeup",
  "personalized_makeup_autumn": "Prefer warm, earthy shades for a harmonious look",
  "personalized_makeup_winter": "Experiment with bright, contrasting colors for expressive makeup",

  "personalized_hair": "Your face shape allows: ",
  "personalized_hair_oval": "You can experiment with different hairstyles as your face shape has balanced proportions",
  "personalized_hair_round": "Choose hairstyles that add height and elongate the face",
  "personalized_hair_square": "Soft waves and layered cuts will help soften your features",
  "personalized_hair_heart": "Hairstyles with volume at the bottom will help balance proportions",
  "personalized_hair_diamond": "Add volume in the temple area with side strands",
  "personalized_hair_rectangle": "Multi-layered cuts will help add necessary volume"
}

[FILE: marinette/i18n/uk.json]
{
  "app_name": "–ë'—é—Ç—ñ-—Ä–µ–∫–æ–º–µ–Ω–¥–∞—Ü—ñ—ó",
  "take_photo": "–ó—Ä–æ–±–∏—Ç–∏ —Ñ–æ—Ç–æ",
  "choose_from_gallery": "–í–∏–±—Ä–∞—Ç–∏ –∑ –≥–∞–ª–µ—Ä–µ—ó",
  "analyzing": "–ê–Ω–∞–ª—ñ–∑—É—î–º–æ –≤–∞—à–µ —Ñ–æ—Ç–æ...",
  "recommendations": "–†–µ–∫–æ–º–µ–Ω–¥–∞—Ü—ñ—ó",
  "face_shape": "–§–æ—Ä–º–∞ –æ–±–ª–∏—á—á—è",
  "color_type": "–ö–æ–ª—å–æ—Ä–æ—Ç–∏–ø",
  "makeup_recommendations": "–ú–∞–∫—ñ—è–∂",
  "hairstyle_recommendations": "–ó–∞—á—ñ—Å–∫–∞",
  "skincare_recommendations": "–î–æ–≥–ª—è–¥ –∑–∞ —à–∫—ñ—Ä–æ—é",
  "error_no_face": "–û–±–ª–∏—á—á—è –Ω–µ –∑–Ω–∞–π–¥–µ–Ω–æ. –°–ø—Ä–æ–±—É–π—Ç–µ —â–µ —Ä–∞–∑.",
  "error_multiple_faces": "–ó–Ω–∞–π–¥–µ–Ω–æ –¥–µ–∫—ñ–ª—å–∫–∞ –æ–±–ª–∏—á. –í–∏–∫–æ—Ä–∏—Å—Ç–æ–≤—É–π—Ç–µ —Ñ–æ—Ç–æ –∑ –æ–¥–Ω–∏–º –æ–±–ª–∏—á—á—è–º.",
  "error_camera": "–ü–æ–º–∏–ª–∫–∞ –∫–∞–º–µ—Ä–∏. –°–ø—Ä–æ–±—É–π—Ç–µ —â–µ —Ä–∞–∑.",
  "error": "–ü–æ–º–∏–ª–∫–∞",
  "info": "–Ü–Ω—Ñ–æ—Ä–º–∞—Ü—ñ—è",
  "share_coming_soon": "–§—É–Ω–∫—Ü—ñ—è –ø–æ—à–∏—Ä–µ–Ω–Ω—è —Å–∫–æ—Ä–æ –∑'—è–≤–∏—Ç—å—Å—è!",
  "analysis_failed": "–ù–µ –≤–¥–∞–ª–æ—Å—è –ø—Ä–æ–∞–Ω–∞–ª—ñ–∑—É–≤–∞—Ç–∏ —Ñ–æ—Ç–æ. –°–ø—Ä–æ–±—É–π—Ç–µ —â–µ —Ä–∞–∑.",
  "welcome_message": "–ó—Ä–æ–±—ñ—Ç—å –∞–±–æ –≤–∏–±–µ—Ä—ñ—Ç—å —Ñ–æ—Ç–æ, —â–æ–± –æ—Ç—Ä–∏–º–∞—Ç–∏ –ø–µ—Ä—Å–æ–Ω–∞–ª—ñ–∑–æ–≤–∞–Ω—ñ –±'—é—Ç—ñ-—Ä–µ–∫–æ–º–µ–Ω–¥–∞—Ü—ñ—ó",
  "history": "–Ü—Å—Ç–æ—Ä—ñ—è",
  "no_history": "–£ –≤–∞—Å —â–µ –Ω–µ–º–∞—î –∑–±–µ—Ä–µ–∂–µ–Ω–∏—Ö —Ä–µ–∑—É–ª—å—Ç–∞—Ç—ñ–≤",
  "confirm_delete": "–ü—ñ–¥—Ç–≤–µ—Ä–¥–∂–µ–Ω–Ω—è –≤–∏–¥–∞–ª–µ–Ω–Ω—è",
  "delete_result_confirmation": "–í–∏ –≤–ø–µ–≤–Ω–µ–Ω—ñ, —â–æ —Ö–æ—á–µ—Ç–µ –≤–∏–¥–∞–ª–∏—Ç–∏ —Ü–µ–π —Ä–µ–∑—É–ª—å—Ç–∞—Ç?",
  "cancel": "–°–∫–∞—Å—É–≤–∞—Ç–∏",
  "delete": "–í–∏–¥–∞–ª–∏—Ç–∏",
  "error_saving_result": "–ü–æ–º–∏–ª–∫–∞ –∑–±–µ—Ä–µ–∂–µ–Ω–Ω—è —Ä–µ–∑—É–ª—å—Ç–∞—Ç—É",
  "error_loading_result": "–ü–æ–º–∏–ª–∫–∞ –∑–∞–≤–∞–Ω—Ç–∞–∂–µ–Ω–Ω—è —Ä–µ–∑—É–ª—å—Ç–∞—Ç—É",
  "error_loading_results": "–ü–æ–º–∏–ª–∫–∞ –∑–∞–≤–∞–Ω—Ç–∞–∂–µ–Ω–Ω—è —Ä–µ–∑—É–ª—å—Ç–∞—Ç—ñ–≤",
  "error_deleting_result": "–ü–æ–º–∏–ª–∫–∞ –≤–∏–¥–∞–ª–µ–Ω–Ω—è —Ä–µ–∑—É–ª—å—Ç–∞—Ç—É",
  "error_sharing": "–ü–æ–º–∏–ª–∫–∞ –ø—ñ–¥ —á–∞—Å –ø–æ—à–∏—Ä–µ–Ω–Ω—è —Ä–µ–∑—É–ª—å—Ç–∞—Ç—ñ–≤",

  "face_shape_oval": "–û–≤–∞–ª—å–Ω–∞",
  "face_shape_round": "–ö—Ä—É–≥–ª–∞",
  "face_shape_square": "–ö–≤–∞–¥—Ä–∞—Ç–Ω–∞",
  "face_shape_heart": "–°–µ—Ä—Ü–µ–ø–æ–¥—ñ–±–Ω–∞",
  "face_shape_diamond": "–î—ñ–∞–º–∞–Ω—Ç–æ–≤–∞",
  "face_shape_rectangle": "–ü—Ä—è–º–æ–∫—É—Ç–Ω–∞",

  "color_type_spring": "–í–µ—Å–Ω–∞",
  "color_type_summer": "–õ—ñ—Ç–æ",
  "color_type_autumn": "–û—Å—ñ–Ω—å",
  "color_type_winter": "–ó–∏–º–∞",

  "season_winter": "–í –∑–∏–º–æ–≤–∏–π –ø–µ—Ä—ñ–æ–¥ –æ—Å–æ–±–ª–∏–≤—É —É–≤–∞–≥—É –ø—Ä–∏–¥—ñ–ª—ñ—Ç—å –∑–≤–æ–ª–æ–∂–µ–Ω–Ω—é —Ç–∞ –∑–∞—Ö–∏—Å—Ç—É —à–∫—ñ—Ä–∏ –≤—ñ–¥ —Ö–æ–ª–æ–¥—É. –í–∏–∫–æ—Ä–∏—Å—Ç–æ–≤—É–π—Ç–µ –±—ñ–ª—å—à –ø–æ–∂–∏–≤–Ω—ñ –∫—Ä–µ–º–∏ —Ç–∞ –∑–∞—Ö–∏—Å–Ω—ñ –±–∞–ª—å–∑–∞–º–∏ –¥–ª—è –≥—É–±.",
  "season_spring": "–í–µ—Å–Ω–æ—é –∑–æ—Å–µ—Ä–µ–¥—å—Ç–µ—Å—å –Ω–∞ –≤—ñ–¥–Ω–æ–≤–ª–µ–Ω–Ω—ñ —à–∫—ñ—Ä–∏ –ø—ñ—Å–ª—è –∑–∏–º–∏. –î–æ–¥–∞–π—Ç–µ –¥–æ –¥–æ–≥–ª—è–¥—É –≤—ñ–¥–ª—É—â—É—é—á—ñ –∑–∞—Å–æ–±–∏ —Ç–∞ –∞–Ω—Ç–∏–æ–∫—Å–∏–¥–∞–Ω—Ç–∏.",
  "season_summer": "–í–ª—ñ—Ç–∫—É –Ω–∞–π–≤–∞–∂–ª–∏–≤—ñ—à–∏–π –µ–ª–µ–º–µ–Ω—Ç –¥–æ–≥–ª—è–¥—É - —Å–æ–Ω—Ü–µ–∑–∞—Ö–∏—Å—Ç. –í–∏–∫–æ—Ä–∏—Å—Ç–æ–≤—É–π—Ç–µ –ª–µ–≥–∫—ñ —Ç–µ–∫—Å—Ç—É—Ä–∏ —Ç–∞ –Ω–µ –∑–∞–±—É–≤–∞–π—Ç–µ –ø—Ä–æ –∑–≤–æ–ª–æ–∂–µ–Ω–Ω—è.",
  "season_autumn": "–í–æ—Å–µ–Ω–∏ —à–∫—ñ—Ä–∞ –ø–æ—Ç—Ä–µ–±—É—î –æ—Å–æ–±–ª–∏–≤–æ–≥–æ –∑–∞—Ö–∏—Å—Ç—É —Ç–∞ –≤—ñ–¥–Ω–æ–≤–ª–µ–Ω–Ω—è. –ó–≤–µ—Ä–Ω—ñ—Ç—å —É–≤–∞–≥—É –Ω–∞ –∑–∞—Å–æ–±–∏ –∑ –≤—ñ—Ç–∞–º—ñ–Ω–∞–º–∏ —Ç–∞ –∞–Ω—Ç–∏–æ–∫—Å–∏–¥–∞–Ω—Ç–∞–º–∏.",

  "makeup_shape_oval": "–ü—ñ–¥–∫—Ä–µ—Å–ª—ñ—Ç—å –ø—Ä–∏—Ä–æ–¥–Ω—ñ –ø—Ä–æ–ø–æ—Ä—Ü—ñ—ó –ª–µ–≥–∫–∏–º –∫–æ–Ω—Ç—É—Ä–∏–Ω–≥–æ–º",
  "makeup_shape_oval_2": "–†—É–º'—è–Ω–∞ –Ω–∞–Ω–æ—Å—ñ—Ç—å –ø–æ –¥—ñ–∞–≥–æ–Ω–∞–ª—ñ –≤–≥–æ—Ä—É –¥–ª—è –¥–æ–¥–∞—Ç–∫–æ–≤–æ–≥–æ –ª—ñ—Ñ—Ç–∏–Ω–≥—É",
  "makeup_shape_oval_3": "–ï–∫—Å–ø–µ—Ä–∏–º–µ–Ω—Ç—É–π—Ç–µ –∑ —Ä—ñ–∑–Ω–∏–º–∏ —Ç–µ—Ö–Ω—ñ–∫–∞–º–∏ - –≤–∞—à–∞ —Ñ–æ—Ä–º–∞ –æ–±–ª–∏—á—á—è —É–Ω—ñ–≤–µ—Ä—Å–∞–ª—å–Ω–∞",
  "makeup_shape_oval_4": "–ê–∫—Ü–µ–Ω—Ç—É–π—Ç–µ —É–≤–∞–≥—É –Ω–∞ –æ—á–∞—Ö –∞–±–æ –≥—É–±–∞—Ö –∑–∞ –≤–∞—à–∏–º –≤–∏–±–æ—Ä–æ–º",
  "makeup_shape_oval_5": "–í–∏–∫–æ—Ä–∏—Å—Ç–æ–≤—É–π—Ç–µ —Ö–∞–π–ª–∞–π—Ç–µ—Ä –Ω–∞ –≤–∏–ª–∏—Ü—è—Ö –¥–ª—è –ø—ñ–¥–∫—Ä–µ—Å–ª–µ–Ω–Ω—è –ø—Ä–∏—Ä–æ–¥–Ω–æ–≥–æ —Ä–µ–ª—å—î—Ñ—É",

  "makeup_shape_round": "–í–∏–∫–æ—Ä–∏—Å—Ç–æ–≤—É–π—Ç–µ –∫–æ–Ω—Ç—É—Ä–∏–Ω–≥ –ø–æ –±–æ–∫–∞–º –æ–±–ª–∏—á—á—è –¥–ª—è –≤–∏–¥–æ–≤–∂–µ–Ω–Ω—è",
  "makeup_shape_round_2": "–ù–∞–Ω–æ—Å—å—Ç–µ —Ä—É–º'—è–Ω–∞ –ø—ñ–¥ –∫—É—Ç–æ–º –¥–æ–≥–æ—Ä–∏ –¥–ª—è –≤–∏—Ç—è–≥—É–≤–∞–Ω–Ω—è —Ñ–æ—Ä–º–∏",
  "makeup_shape_round_3": "–°—Ç–≤–æ—Ä—é–π—Ç–µ —á—ñ—Ç–∫—ñ –∫—É—Ç–∏ –ø—Ä–∏ –Ω–∞–Ω–µ—Å–µ–Ω–Ω—ñ —Ç–æ–Ω–∞–ª—å–Ω–æ–≥–æ –∑–∞—Å–æ–±—É –≤ –∑–æ–Ω—ñ —â–µ–ª–µ–ø–∏",
  "makeup_shape_round_4": "–†–æ–±—ñ—Ç—å –∞–∫—Ü–µ–Ω—Ç –Ω–∞ –≤–∏–ª–∏—Ü—è—Ö –∑–∞ –¥–æ–ø–æ–º–æ–≥–æ—é —Ö–∞–π–ª–∞–π—Ç–µ—Ä–∞",
  "makeup_shape_round_5": "–í–∏–∫–æ—Ä–∏—Å—Ç–æ–≤—É–π—Ç–µ —Ç–µ—Ö–Ω—ñ–∫—É –æ–≤–∞–ª—å–Ω–æ–≥–æ –∫–æ–Ω—Ç—É—Ä–∏–Ω–≥—É –Ω–æ—Å–∞",
  
  "makeup_shape_square": "–ü–æ–º'—è–∫—à—É–π—Ç–µ –∫—É—Ç–∏ –æ–±–ª–∏—á—á—è –∑–∞ –¥–æ–ø–æ–º–æ–≥–æ—é —Ä–æ–∑—Ç—É—à–æ–≤–∞–Ω–æ–≥–æ –∫–æ–Ω—Ç—É—Ä–∏–Ω–≥—É",
  "makeup_shape_square_2": "–ù–∞–Ω–æ—Å—å—Ç–µ —Ä—É–º'—è–Ω–∞ –∫—Ä—É–≥–æ–≤–∏–º–∏ —Ä—É—Ö–∞–º–∏ –¥–ª—è –ø–æ–º'—è–∫—à–µ–Ω–Ω—è —Ä–∏—Å",
  "makeup_shape_square_3": "–£–Ω–∏–∫–∞–π—Ç–µ —Ä—ñ–∑–∫–∏—Ö –ª—ñ–Ω—ñ–π –ø—Ä–∏ –Ω–∞–Ω–µ—Å–µ–Ω–Ω—ñ –º–∞–∫—ñ—è–∂—É",
  "makeup_shape_square_4": "–î–æ–¥–∞–≤–∞–π—Ç–µ —Å–≤—ñ—Ç–ª–æ–≤—ñ–¥–±–∏–≤–∞—é—á—ñ —á–∞—Å—Ç–∏–Ω–∫–∏ –≤ –∑–æ–Ω—ñ —Å–∫—É–ª",
  "makeup_shape_square_5": "–í–∏–∫–æ—Ä–∏—Å—Ç–æ–≤—É–π—Ç–µ –º'—è–∫—ñ –ø–∞—Å—Ç–µ–ª—å–Ω—ñ —Ç–æ–Ω–∏ –¥–ª—è –æ—á–µ–π",
  
  "makeup_shape_heart": "–ü—ñ–¥–∫—Ä–µ—Å–ª—ñ—Ç—å –≤–∏–ª–∏—Ü—ñ, —â–æ–± –∑–±–∞–ª–∞–Ω—Å—É–≤–∞—Ç–∏ —à–∏—Ä—à–µ —á–æ–ª–æ",
  "makeup_shape_heart_2": "–í–∏–∫–æ—Ä–∏—Å—Ç–æ–≤—É–π—Ç–µ —Ö–∞–π–ª–∞–π—Ç–µ—Ä –Ω–∞ –ø—ñ–¥–±–æ—Ä—ñ–¥–¥—ñ –¥–ª—è –≤—ñ–∑—É–∞–ª—å–Ω–æ–≥–æ –ø–æ–¥–æ–≤–∂–µ–Ω–Ω—è",
  "makeup_shape_heart_3": "–ó–∞—Ç–µ–º–Ω—é–π—Ç–µ –∑–æ–≤–Ω—ñ—à–Ω—ñ –∫—É—Ç–∏ —á–æ–ª–∞ –¥–ª—è –±–∞–ª–∞–Ω—Å—É",
  "makeup_shape_heart_4": "–ù–∞–Ω–æ—Å—ñ—Ç—å —Ä—É–º'—è–Ω–∞ –±–ª–∏–∂—á–µ –¥–æ —Ü–µ–Ω—Ç—Ä—É —â—ñ–∫",
  "makeup_shape_heart_5": "–ê–∫—Ü–µ–Ω—Ç—É–π—Ç–µ –Ω–∏–∂–Ω—é —á–∞—Å—Ç–∏–Ω—É –æ–±–ª–∏—á—á—è –∑–∞ –¥–æ–ø–æ–º–æ–≥–æ—é —Å–≤—ñ—Ç–ª–∏—Ö –≤—ñ–¥—Ç—ñ–Ω–∫—ñ–≤",
  
  "makeup_shape_diamond": "–ö–æ–Ω—Ü–µ–Ω—Ç—Ä—É–π—Ç–µ –∫–æ–Ω—Ç—É—Ä–∏–Ω–≥ –Ω–∞ —Å–∫—Ä–æ–Ω—è—Ö —Ç–∞ –ø—ñ–¥–±–æ—Ä—ñ–¥–¥—ñ",
  "makeup_shape_diamond_2": "–ù–∞–Ω–æ—Å—å—Ç–µ —Ä—É–º'—è–Ω–∞ –≥–æ—Ä–∏–∑–æ–Ω—Ç–∞–ª—å–Ω–æ –¥–ª—è –ø–æ–º'—è–∫—à–µ–Ω–Ω—è –≥–æ—Å—Ç—Ä–∏—Ö –∫—É—Ç—ñ–≤",
  "makeup_shape_diamond_3": "–ü—ñ–¥–∫—Ä–µ—Å–ª—é–π—Ç–µ —Ü–µ–Ω—Ç—Ä –æ–±–ª–∏—á—á—è —Å–≤—ñ—Ç–ª–∏–º–∏ –≤—ñ–¥—Ç—ñ–Ω–∫–∞–º–∏",
  "makeup_shape_diamond_4": "–í–∏–∫–æ—Ä–∏—Å—Ç–æ–≤—É–π—Ç–µ –º'—è–∫—ñ –ø–µ—Ä–µ—Ö–æ–¥–∏ –ø—Ä–∏ —Ä–æ–∑—Ç—É—à–æ–≤—Ü—ñ",
  "makeup_shape_diamond_5": "–î–æ–¥–∞–≤–∞–π—Ç–µ –æ–±'—î–º –≤ –Ω–∏–∂–Ω—ñ–π —á–∞—Å—Ç–∏–Ω—ñ –æ–±–ª–∏—á—á—è —Å–≤—ñ—Ç–ª–∏–º–∏ —Ç–µ–∫—Å—Ç—É—Ä–∞–º–∏",
  
  "makeup_shape_rectangle": "–°—Ç–≤–æ—Ä—é–π—Ç–µ –º'—è–∫—ñ –ø–µ—Ä–µ—Ö–æ–¥–∏ –ø—Ä–∏ –∫–æ–Ω—Ç—É—Ä–∏–Ω–≥—É",
  "makeup_shape_rectangle_2": "–í–∏–∫–æ—Ä–∏—Å—Ç–æ–≤—É–π—Ç–µ —Ä—É–º'—è–Ω–∞ –¥–ª—è –¥–æ–¥–∞–Ω–Ω—è –æ–∫—Ä—É–≥–ª–æ—Å—Ç—ñ",
  "makeup_shape_rectangle_3": "–ü—ñ–¥–∫—Ä–µ—Å–ª—ñ—Ç—å –≤–∏–ª–∏—Ü—ñ –¥–ª—è –±–∞–ª–∞–Ω—Å—É –ø—Ä–æ–ø–æ—Ä—Ü—ñ–π",
  "makeup_shape_rectangle_4": "–î–æ–¥–∞–≤–∞–π—Ç–µ —Å–≤—ñ—Ç–ª—ñ –∞–∫—Ü–µ–Ω—Ç–∏ –≤ —Ü–µ–Ω—Ç—Ä–∞–ª—å–Ω—ñ–π —á–∞—Å—Ç–∏–Ω—ñ –æ–±–ª–∏—á—á—è",
  "makeup_shape_rectangle_5": "–£–Ω–∏–∫–∞–π—Ç–µ –≤–µ—Ä—Ç–∏–∫–∞–ª—å–Ω–∏—Ö –ª—ñ–Ω—ñ–π –ø—Ä–∏ –Ω–∞–Ω–µ—Å–µ–Ω–Ω—ñ –º–∞–∫—ñ—è–∂—É",
  
  "makeup_color_spring": "–û–±–∏—Ä–∞–π—Ç–µ —Ç–µ–ø–ª—ñ, —è—Å–∫—Ä–∞–≤—ñ –≤—ñ–¥—Ç—ñ–Ω–∫–∏ –ø–æ–º–∞–¥–∏: –∫–æ—Ä–∞–ª, –ø–µ—Ä—Å–∏–∫, —Ç–µ–ø–ª–∏–π —Ä–æ–∂–µ–≤–∏–π",
  "makeup_color_spring_2": "–í–∏–∫–æ—Ä–∏—Å—Ç–æ–≤—É–π—Ç–µ –∑–æ–ª–æ—Ç–∏—Å—Ç—ñ —Ç–∞ –ø–µ—Ä—Å–∏–∫–æ–≤—ñ —Ä—É–º'—è–Ω–∞",
  "makeup_color_spring_3": "–î–ª—è –æ—á–µ–π –ø—ñ–¥—ñ–π–¥—É—Ç—å –±—Ä–æ–Ω–∑–æ–≤—ñ, –∑–æ–ª–æ—Ç–∏—Å—Ç—ñ —Ç–∞ —Ç–µ–ø–ª—ñ –∫–æ—Ä–∏—á–Ω–µ–≤—ñ —Ç—ñ–Ω—ñ",
  "makeup_color_spring_4": "–ï–∫—Å–ø–µ—Ä–∏–º–µ–Ω—Ç—É–π—Ç–µ –∑ —Ç–µ—Ä–∞–∫–æ—Ç–æ–≤–∏–º–∏ –≤—ñ–¥—Ç—ñ–Ω–∫–∞–º–∏ –¥–ª—è –≥—É–±",
  "makeup_color_spring_5": "–í–∏–∫–æ—Ä–∏—Å—Ç–æ–≤—É–π—Ç–µ —Ç–µ–ø–ª—ñ –≤—ñ–¥—Ç—ñ–Ω–∫–∏ –±—Ä–æ–Ω–∑–µ—Ä–∞",

  "makeup_color_summer": "–û–±–∏—Ä–∞–π—Ç–µ —Ö–æ–ª–æ–¥–Ω—ñ, –ø—Ä–∏–≥–ª—É—à–µ–Ω—ñ –≤—ñ–¥—Ç—ñ–Ω–∫–∏ –ø–æ–º–∞–¥–∏: —Ä–æ–∂–µ–≤–∏–π, –º–∞–ª–∏–Ω–æ–≤–∏–π",
  "makeup_color_summer_2": "–í–∏–∫–æ—Ä–∏—Å—Ç–æ–≤—É–π—Ç–µ —Ö–æ–ª–æ–¥–Ω—ñ —Ä–æ–∂–µ–≤—ñ —Ç–∞ –ª–∞–≤–∞–Ω–¥–æ–≤—ñ —Ä—É–º'—è–Ω–∞",
  "makeup_color_summer_3": "–î–ª—è –æ—á–µ–π —ñ–¥–µ–∞–ª—å–Ω—ñ —Å—Ä—ñ–±–ª—è—Å—Ç—ñ, —Å—ñ—Ä—ñ —Ç–∞ –ø—Ä–æ—Ö–æ–ª–æ–¥–Ω—ñ –∫–æ—Ä–∏—á–Ω–µ–≤—ñ —Ç–æ–Ω–∏",
  "makeup_color_summer_4": "–£–Ω–∏–∫–∞–π—Ç–µ –∑–∞–Ω–∞–¥—Ç–æ —è—Å–∫—Ä–∞–≤–∏—Ö —Ç–∞ —Ç–µ–ø–ª–∏—Ö –≤—ñ–¥—Ç—ñ–Ω–∫—ñ–≤",
  "makeup_color_summer_5": "–í—ñ–¥–¥–∞–≤–∞–π—Ç–µ –ø–µ—Ä–µ–≤–∞–≥—É –ø–∞—Å—Ç–µ–ª—å–Ω–∏–º —Ç–æ–Ω–∞–º",

  "makeup_color_autumn": "–û–±–∏—Ä–∞–π—Ç–µ —Ç–µ–ø–ª—ñ, –∑–µ–º–ª–∏—Å—Ç—ñ –≤—ñ–¥—Ç—ñ–Ω–∫–∏ –ø–æ–º–∞–¥–∏: —Ç–µ—Ä–∞–∫–æ—Ç, –º—ñ–¥—å",
  "makeup_color_autumn_2": "–í–∏–∫–æ—Ä–∏—Å—Ç–æ–≤—É–π—Ç–µ —Ç–µ–ø–ª—ñ –∫–æ—Ä–∏—á–Ω–µ–≤—ñ —Ç–∞ —Ç–µ—Ä–∞–∫–æ—Ç–æ–≤—ñ —Ä—É–º'—è–Ω–∞",
  "makeup_color_autumn_3": "–î–ª—è –æ—á–µ–π –ø—ñ–¥—ñ–π–¥—É—Ç—å –∑–µ–ª–µ–Ω—ñ, –∑–æ–ª–æ—Ç–∏—Å—Ç–æ-–∫–æ—Ä–∏—á–Ω–µ–≤—ñ —Ç–æ–Ω–∏",
  "makeup_color_autumn_4": "–ï–∫—Å–ø–µ—Ä–∏–º–µ–Ω—Ç—É–π—Ç–µ –∑ –Ω–∞—Å–∏—á–µ–Ω–∏–º–∏ –æ—Å—ñ–Ω–Ω—ñ–º–∏ –∫–æ–ª—å–æ—Ä–∞–º–∏",
  "makeup_color_autumn_5": "–î–æ–¥–∞–≤–∞–π—Ç–µ –∑–æ–ª–æ—Ç–∏—Å—Ç–∏–π —à–∏–º–º–µ—Ä –¥–ª—è —Å—è—è–Ω–Ω—è",

  "makeup_color_winter": "–û–±–∏—Ä–∞–π—Ç–µ —è—Å–∫—Ä–∞–≤—ñ, –∫–æ–Ω—Ç—Ä–∞—Å—Ç–Ω—ñ –≤—ñ–¥—Ç—ñ–Ω–∫–∏ –ø–æ–º–∞–¥–∏: —á–µ—Ä–≤–æ–Ω–∏–π, —Ñ—É–∫—Å—ñ—è",
  "makeup_color_winter_2": "–í–∏–∫–æ—Ä–∏—Å—Ç–æ–≤—É–π—Ç–µ —Ö–æ–ª–æ–¥–Ω—ñ —Ä–æ–∂–µ–≤—ñ —Ç–∞ —è–≥—ñ–¥–Ω—ñ —Ä—É–º'—è–Ω–∞",
  "makeup_color_winter_3": "–î–ª—è –æ—á–µ–π –ø—ñ–¥—ñ–π–¥—É—Ç—å –¥–∏–º—á–∞—Å—Ç—ñ, —Å–∏–Ω—ñ —Ç–∞ —Å—Ä—ñ–±–ª—è—Å—Ç—ñ –≤—ñ–¥—Ç—ñ–Ω–∫–∏",
  "makeup_color_winter_4": "–ï–∫—Å–ø–µ—Ä–∏–º–µ–Ω—Ç—É–π—Ç–µ –∑ –Ω–∞—Å–∏—á–µ–Ω–∏–º–∏ –∫–æ–ª—å–æ—Ä–∞–º–∏",
  "makeup_color_winter_5": "–í–∏–∫–æ—Ä–∏—Å—Ç–æ–≤—É–π—Ç–µ –∫–æ–Ω—Ç—Ä–∞—Å—Ç–Ω—ñ –∫–æ–º–±—ñ–Ω–∞—Ü—ñ—ó",

  "haircolor_spring": "–ó–æ–ª–æ—Ç–∏—Å—Ç—ñ –≤—ñ–¥—Ç—ñ–Ω–∫–∏ –±–ª–æ–Ω–¥—É –ø—ñ–¥–∫—Ä–µ—Å–ª—è—Ç—å –ø—Ä–∏—Ä–æ–¥–Ω—É —è—Å–∫—Ä–∞–≤—ñ—Å—Ç—å",
  "haircolor_spring_2": "–ú–µ–¥–æ–≤—ñ —Ç–∞ –∫–∞—Ä–∞–º–µ–ª—å–Ω—ñ —Ç–æ–Ω–∏ —á—É–¥–æ–≤–æ –ø—ñ–¥—ñ–π–¥—É—Ç—å",
  "haircolor_spring_3": "–ï–∫—Å–ø–µ—Ä–∏–º–µ–Ω—Ç—É–π—Ç–µ –∑ —Ç–µ–ø–ª–∏–º–∏ —Ä—É–¥–∏–º–∏ –≤—ñ–¥—Ç—ñ–Ω–∫–∞–º–∏",

  "haircolor_summer": "–û–±–∏—Ä–∞–π—Ç–µ —Ö–æ–ª–æ–¥–Ω—ñ –ø–ª–∞—Ç–∏–Ω–æ–≤—ñ —Ç–∞ –ø–æ–ø–µ–ª—è—Å—Ç—ñ –≤—ñ–¥—Ç—ñ–Ω–∫–∏",
  "haircolor_summer_2": "–ü–µ—Ä–ª–∏–Ω–Ω–∏–π –±–ª–æ–Ω–¥ –ø—ñ–¥–∫—Ä–µ—Å–ª–∏—Ç—å –≤–∞—à—É –∑–æ–≤–Ω—ñ—à–Ω—ñ—Å—Ç—å",
  "haircolor_summer_3": "–ï–∫—Å–ø–µ—Ä–∏–º–µ–Ω—Ç—É–π—Ç–µ –∑ –ø–∞—Å—Ç–µ–ª—å–Ω–∏–º–∏ —Ç–æ–Ω–∞–º–∏",

  "haircolor_autumn": "–û–±–∏—Ä–∞–π—Ç–µ –Ω–∞—Å–∏—á–µ–Ω—ñ –∫–∞—à—Ç–∞–Ω–æ–≤—ñ —Ç–∞ –º—ñ–¥–Ω—ñ –≤—ñ–¥—Ç—ñ–Ω–∫–∏",
  "haircolor_autumn_2": "–ó–æ–ª–æ—Ç–∏—Å—Ç–æ-–∫–æ—Ä–∏—á–Ω–µ–≤—ñ —Ç–æ–Ω–∏ –ø—ñ–¥–∫—Ä–µ—Å–ª—è—Ç—å –ø—Ä–∏—Ä–æ–¥–Ω—É –∫—Ä–∞—Å—É",
  "haircolor_autumn_3": "–ï–∫—Å–ø–µ—Ä–∏–º–µ–Ω—Ç—É–π—Ç–µ –∑ —Ç–µ–ø–ª–∏–º–∏ —Ä—É–¥–∏–º–∏ —Ç–æ–Ω–∞–º–∏",

  "haircolor_winter": "–û–±–∏—Ä–∞–π—Ç–µ –∫–æ–Ω—Ç—Ä–∞—Å—Ç–Ω—ñ –∫–æ–ª—å–æ—Ä–∏ - —á–æ—Ä–Ω–∏–π –∞–±–æ –ø–ª–∞—Ç–∏–Ω–æ–≤–∏–π –±–ª–æ–Ω–¥",
  "haircolor_winter_2": "–•–æ–ª–æ–¥–Ω—ñ —Ç–µ–º–Ω—ñ –≤—ñ–¥—Ç—ñ–Ω–∫–∏ –ø—ñ–¥–∫—Ä–µ—Å–ª—è—Ç—å –≤–∞—à—É –∑–æ–≤–Ω—ñ—à–Ω—ñ—Å—Ç—å",
  "haircolor_winter_3": "–°–ø—Ä–æ–±—É–π—Ç–µ —Å–∏–Ω—é–≤–∞—Ç–æ-—á–æ—Ä–Ω—ñ —Ç–æ–Ω–∏",

  "hairstyle_oval": "–í–∞–º –ø—ñ–¥—Ö–æ–¥–∏—Ç—å –±—ñ–ª—å—à—ñ—Å—Ç—å –∑–∞—á—ñ—Å–æ–∫ –∑–∞–≤–¥—è–∫–∏ –ø—Ä–æ–ø–æ—Ä—Ü—ñ–π–Ω—ñ–π —Ñ–æ—Ä–º—ñ –æ–±–ª–∏—á—á—è",
  "hairstyle_oval_2": "–°–ø—Ä–æ–±—É–π—Ç–µ –¥–æ–≤–≥–µ –≤–æ–ª–æ—Å—Å—è –∑ –ª–µ–≥–∫–∏–º–∏ —Ö–≤–∏–ª—è–º–∏ –¥–ª—è —Ä–æ–º–∞–Ω—Ç–∏—á–Ω–æ–≥–æ –æ–±—Ä–∞–∑—É",
  "hairstyle_oval_3": "–°–µ—Ä–µ–¥–Ω—è –¥–æ–≤–∂–∏–Ω–∞ –∑ –≥—Ä–∞–¥—É—é–≤–∞–Ω–Ω—è–º –ø—ñ–¥–∫—Ä–µ—Å–ª–∏—Ç—å —Ä–∏—Å–∏ –æ–±–ª–∏—á—á—è",
  "hairstyle_oval_4": "–ú–æ–∂–Ω–∞ –µ–∫—Å–ø–µ—Ä–∏–º–µ–Ω—Ç—É–≤–∞—Ç–∏ –∑ —á—É–±—á–∏–∫–æ–º –±—É–¥—å-—è–∫–æ—ó —Ñ–æ—Ä–º–∏",
  "hairstyle_oval_5": "–ü—ñ–¥—ñ–π–¥—É—Ç—å —è–∫ –ø—Ä—è–º—ñ, —Ç–∞–∫ —ñ –∫—É—á–µ—Ä—è–≤—ñ –∑–∞—á—ñ—Å–∫–∏",
  
  "hairstyle_round": "–û–±–∏—Ä–∞–π—Ç–µ –∑–∞—á—ñ—Å–∫–∏, —â–æ –¥–æ–¥–∞—é—Ç—å –≤–∏—Å–æ—Ç–∏ —Ç–∞ –≤–∏–¥–æ–≤–∂—É—é—Ç—å –æ–±–ª–∏—á—á—è",
  "hairstyle_round_2": "–£–Ω–∏–∫–∞–π—Ç–µ –∑–∞–Ω–∞–¥—Ç–æ –æ–±'—î–º–Ω–∏—Ö —É–∫–ª–∞–¥–æ–∫ –∑ –±–æ–∫—ñ–≤",
  "hairstyle_round_3": "–ê—Å–∏–º–µ—Ç—Ä–∏—á–Ω—ñ —Å—Ç—Ä–∏–∂–∫–∏ –¥–æ–ø–æ–º–æ–∂—É—Ç—å –≤–∏–¥–æ–≤–∂–∏—Ç–∏ –æ–±–ª–∏—á—á—è",
  "hairstyle_round_4": "–î–æ–≤–≥–µ –≤–æ–ª–æ—Å—Å—è –∑ —Ä–≤–∞–Ω–∏–º–∏ –∫—ñ–Ω—Ü—è–º–∏ —Å—Ç–≤–æ—Ä–∏—Ç—å –ø–æ—Ç—Ä—ñ–±–Ω–∏–π –µ—Ñ–µ–∫—Ç",
  "hairstyle_round_5": "–ö–æ—Å–∏–π —á—É–±—á–∏–∫ –¥–æ–ø–æ–º–æ–∂–µ –∑—Ä–æ–±–∏—Ç–∏ –æ–±–ª–∏—á—á—è –±—ñ–ª—å—à –≤–∏—Ç–æ–Ω—á–µ–Ω–∏–º",
  
  "hairstyle_square": "–û–±–∏—Ä–∞–π—Ç–µ –º'—è–∫—ñ, —Ö–≤–∏–ª—è—Å—Ç—ñ —É–∫–ª–∞–¥–∫–∏ –¥–ª—è –ø–æ–º'—è–∫—à–µ–Ω–Ω—è —Ä–∏—Å",
  "hairstyle_square_2": "–£–Ω–∏–∫–∞–π—Ç–µ –ø—Ä—è–º–æ–≥–æ –≤–æ–ª–æ—Å—Å—è –∑ —á—ñ—Ç–∫–∏–º–∏ –ª—ñ–Ω—ñ—è–º–∏",
  "hairstyle_square_3": "–ë–∞–≥–∞—Ç–æ—à–∞—Ä–æ–≤—ñ —Å—Ç—Ä–∏–∂–∫–∏ –¥–æ–¥–∞–¥—É—Ç—å –º'—è–∫–æ—Å—Ç—ñ",
  "hairstyle_square_4": "–î–æ–≤–∂–∏–Ω–∞ –Ω–∏–∂—á–µ –ø—ñ–¥–±–æ—Ä—ñ–¥–¥—è –ø–æ–º'—è–∫—à–∏—Ç—å –ª—ñ–Ω—ñ—é —â–µ–ª–µ–ø–∏",
  "hairstyle_square_5": "–õ–µ–≥–∫—ñ –ª–æ–∫–æ–Ω–∏ –±—ñ–ª—è –æ–±–ª–∏—á—á—è —Å—Ç–≤–æ—Ä—è—Ç—å —Ä–æ–º–∞–Ω—Ç–∏—á–Ω–∏–π –æ–±—Ä–∞–∑",
  
  "hairstyle_heart": "–û–±–∏—Ä–∞–π—Ç–µ –∑–∞—á—ñ—Å–∫–∏ –∑ –æ–±'—î–º–æ–º –≤–Ω–∏–∑—É –¥–ª—è –±–∞–ª–∞–Ω—Å—É",
  "hairstyle_heart_2": "–£–Ω–∏–∫–∞–π—Ç–µ –∑–∞–Ω–∞–¥—Ç–æ –æ–±'—î–º–Ω–∏—Ö —É–∫–ª–∞–¥–æ–∫ —É –≤–µ—Ä—Ö–Ω—ñ–π —á–∞—Å—Ç–∏–Ω—ñ",
  "hairstyle_heart_3": "–°–µ—Ä–µ–¥–Ω—è –¥–æ–≤–∂–∏–Ω–∞ –∑ –º'—è–∫–∏–º–∏ —à–∞—Ä–∞–º–∏ —ñ–¥–µ–∞–ª—å–Ω–æ –ø—ñ–¥—ñ–π–¥–µ",
  "hairstyle_heart_4": "–ë–æ–∫–æ–≤—ñ –ø—Ä–æ–¥—ñ–ª–∏ –¥–æ–ø–æ–º–æ–∂—É—Ç—å –∑–±–∞–ª–∞–Ω—Å—É–≤–∞—Ç–∏ —Ä–∏—Å–∏",
  "hairstyle_heart_5": "–î–æ–≤–≥–∏–π –±–æ–∫–æ–≤–∏–π —á—É–±—á–∏–∫ –ø–æ–º'—è–∫—à–∏—Ç—å –ª—ñ–Ω—ñ—é —á–æ–ª–∞",
  
  "hairstyle_diamond": "–û–±–∏—Ä–∞–π—Ç–µ –∑–∞—á—ñ—Å–∫–∏ –∑ –æ–±'—î–º–æ–º —É —Å–∫—Ä–æ–Ω–µ–≤—ñ–π –∑–æ–Ω—ñ",
  "hairstyle_diamond_2": "–ï–∫—Å–ø–µ—Ä–∏–º–µ–Ω—Ç—É–π—Ç–µ –∑ —à–∞—Ä—É–≤–∞—Ç–∏–º–∏ —Å—Ç—Ä–∏–∂–∫–∞–º–∏",
  "hairstyle_diamond_3": "–î–æ–≤–∂–∏–Ω–∞ –¥–æ –ø–ª–µ—á–µ–π –∞–±–æ –Ω–∏–∂—á–µ –Ω–∞–π–±—ñ–ª—å—à –≤–¥–∞–ª–∞",
  "hairstyle_diamond_4": "–£–Ω–∏–∫–∞–π—Ç–µ –∑–∞–Ω–∞–¥—Ç–æ –ø—Ä–∏–ª–µ–≥–ª–∏—Ö –¥–æ –≥–æ–ª–æ–≤–∏ –∑–∞—á—ñ—Å–æ–∫",
  "hairstyle_diamond_5": "–ú'—è–∫—ñ —Ö–≤–∏–ª—ñ —Å–µ—Ä–µ–¥–Ω—å–æ—ó –¥–æ–≤–∂–∏–Ω–∏ –ø—ñ–¥–∫—Ä–µ—Å–ª—è—Ç—å –≤–∞—à—É —Ñ–æ—Ä–º—É –æ–±–ª–∏—á—á—è",
  
  "hairstyle_rectangle": "–û–±–∏—Ä–∞–π—Ç–µ –±–∞–≥–∞—Ç–æ—à–∞—Ä–æ–≤—ñ —Å—Ç—Ä–∏–∂–∫–∏ –¥–ª—è –¥–æ–¥–∞–Ω–Ω—è –æ–±'—î–º—É",
  "hairstyle_rectangle_2": "–î–æ–¥–∞–π—Ç–µ –æ–±'—î–º—É –∑ –±–æ–∫—ñ–≤ –¥–ª—è –±–∞–ª–∞–Ω—Å—É –ø—Ä–æ–ø–æ—Ä—Ü—ñ–π",
  "hairstyle_rectangle_3": "–£–Ω–∏–∫–∞–π—Ç–µ –∑–∞–Ω–∞–¥—Ç–æ –¥–æ–≤–≥–æ–≥–æ –ø—Ä—è–º–æ–≥–æ –≤–æ–ª–æ—Å—Å—è",
  "hairstyle_rectangle_4": "–ß—É–±—á–∏–∫ –¥–æ–ø–æ–º–æ–∂–µ –≤—ñ–∑—É–∞–ª—å–Ω–æ —Å–∫–æ—Ä–æ—Ç–∏—Ç–∏ –¥–æ–≤–∂–∏–Ω—É –æ–±–ª–∏—á—á—è",
  "hairstyle_rectangle_5": "–ö–∞—Å–∫–∞–¥–Ω—ñ —Å—Ç—Ä–∏–∂–∫–∏ —Å—Ç–≤–æ—Ä—è—Ç—å –ø–æ—Ç—Ä—ñ–±–Ω–∏–π –æ–±'—î–º",
  
  "skincare_recommendation_1": "–û–±–æ–≤'—è–∑–∫–æ–≤–æ –≤–∏–∫–æ—Ä–∏—Å—Ç–æ–≤—É–π—Ç–µ —Å–æ–Ω—Ü–µ–∑–∞—Ö–∏—Å–Ω–∏–π –∫—Ä–µ–º —â–æ–¥–Ω—è",
  "skincare_recommendation_2": "–û—á–∏—â–∞–π—Ç–µ —à–∫—ñ—Ä—É –¥–≤—ñ—á—ñ –Ω–∞ –¥–µ–Ω—å –º'—è–∫–∏–º –∑–∞—Å–æ–±–æ–º",
  "skincare_recommendation_3": "–ù–µ –∑–∞–±—É–≤–∞–π—Ç–µ –ø—Ä–æ –∑–≤–æ–ª–æ–∂–µ–Ω–Ω—è —à–∫—ñ—Ä–∏",
  "skincare_recommendation_4": "–†–µ–≥—É–ª—è—Ä–Ω–æ —Ä–æ–±—ñ—Ç—å –ø—ñ–ª—ñ–Ω–≥ —Ç–∞ –≤—ñ–¥–ª—É—â—É–≤–∞–Ω–Ω—è",
  "skincare_recommendation_5": "–í–∏–∫–æ—Ä–∏—Å—Ç–æ–≤—É–π—Ç–µ —Å–∏—Ä–æ–≤–∞—Ç–∫–∏ –∑ –∞–∫—Ç–∏–≤–Ω–∏–º–∏ –∫–æ–º–ø–æ–Ω–µ–Ω—Ç–∞–º–∏",
  
  "skincare_spring": "–í–∏–∫–æ—Ä–∏—Å—Ç–æ–≤—É–π—Ç–µ –ª–µ–≥–∫—ñ —Ç–µ–∫—Å—Ç—É—Ä–∏ –∑–∞—Å–æ–±—ñ–≤",
  "skincare_spring_2": "–ó–≤–µ—Ä–Ω—ñ—Ç—å —É–≤–∞–≥—É –Ω–∞ –∑–∞—Å–æ–±–∏ –∑ –≤—ñ—Ç–∞–º—ñ–Ω–æ–º –°",
  "skincare_spring_3": "–î–æ–¥–∞–π—Ç–µ –¥–æ –¥–æ–≥–ª—è–¥—É –∞–Ω—Ç–∏–æ–∫—Å–∏–¥–∞–Ω—Ç–∏",
  "skincare_spring_4": "–ó–∞—Ö–∏—â–∞–π—Ç–µ—Å—å –≤—ñ–¥ –ø—ñ–≥–º–µ–Ω—Ç–∞—Ü—ñ—ó SPF 30-50",
  "skincare_spring_5": "–û–±–∏—Ä–∞–π—Ç–µ –∑–∞—Å–ø–æ–∫—ñ–π–ª–∏–≤—ñ –º–∞—Å–∫–∏ –¥–ª—è —á—É—Ç–ª–∏–≤–æ—ó —à–∫—ñ—Ä–∏",
  
  "skincare_summer": "–í–∏–∫–æ—Ä–∏—Å—Ç–æ–≤—É–π—Ç–µ –Ω–µ–∫–æ–º–µ–¥–æ–≥–µ–Ω–Ω—ñ –∑–∞—Å–æ–±–∏",
  "skincare_summer_2": "–ó–≤–æ–ª–æ–∂—É–π—Ç–µ —à–∫—ñ—Ä—É –ª–µ–≥–∫–∏–º–∏ –≥–µ–ª–µ–≤–∏–º–∏ —Ç–µ–∫—Å—Ç—É—Ä–∞–º–∏",
  "skincare_summer_3": "–ó–∞—Ö–∏—â–∞–π—Ç–µ—Å—å –≤—ñ–¥ —Å–æ–Ω—Ü—è SPF 50+",
  "skincare_summer_4": "–î–æ–¥–∞–π—Ç–µ –¥–æ –¥–æ–≥–ª—è–¥—É –Ω—ñ–∞—Ü–∏–Ω–∞–º—ñ–¥",
  "skincare_summer_5": "–†–µ–≥—É–ª—è—Ä–Ω–æ —Ä–æ–±—ñ—Ç—å –∑–∞—Å–ø–æ–∫—ñ–π–ª–∏–≤—ñ –º–∞—Å–∫–∏",
  
  "skincare_autumn": "–û–±–∏—Ä–∞–π—Ç–µ –ø–æ–∂–∏–≤–Ω—ñ –∫—Ä–µ–º–∏ –∑ –±–∞–≥–∞—Ç–æ—é —Ç–µ–∫—Å—Ç—É—Ä–æ—é",
  "skincare_autumn_2": "–í–∏–∫–æ—Ä–∏—Å—Ç–æ–≤—É–π—Ç–µ –æ–ª—ñ—ó –¥–ª—è –¥–æ–¥–∞—Ç–∫–æ–≤–æ–≥–æ –∂–∏–≤–ª–µ–Ω–Ω—è",
  "skincare_autumn_3": "–ó–∞—Ö–∏—â–∞–π—Ç–µ—Å—å –≤—ñ–¥ —Å–æ–Ω—Ü—è SPF 30+",
  "skincare_autumn_4": "–ó–≤–µ—Ä—Ç–∞–π—Ç–µ —É–≤–∞–≥—É –Ω–∞ –∑–∞—Å–æ–±–∏ –∑ —Ä–µ—Ç–∏–Ω–æ–ª–æ–º",
  "skincare_autumn_5": "–†–µ–≥—É–ª—è—Ä–Ω–æ –≤–∏–∫–æ—Ä–∏—Å—Ç–æ–≤—É–π—Ç–µ –∑–≤–æ–ª–æ–∂—É—é—á—ñ –º–∞—Å–∫–∏",
  
  "skincare_winter": "–í–∏–∫–æ—Ä–∏—Å—Ç–æ–≤—É–π—Ç–µ –∫—Ä–µ–º–∏ –∑ –Ω–∞—Å–∏—á–µ–Ω–æ—é —Ç–µ–∫—Å—Ç—É—Ä–æ—é",
  "skincare_winter_2": "–î–æ–¥–∞–π—Ç–µ –¥–æ –¥–æ–≥–ª—è–¥—É –ø–µ–ø—Ç–∏–¥–∏ —Ç–∞ —Ü–µ—Ä–∞–º–∏–¥–∏",
  "skincare_winter_3": "–ó–∞—Ö–∏—â–∞–π—Ç–µ—Å—å –≤—ñ–¥ —Å–æ–Ω—Ü—è SPF 50+",
  "skincare_winter_4": "–ó–≤–µ—Ä–Ω—ñ—Ç—å —É–≤–∞–≥—É –Ω–∞ –∑–∞—Å–æ–±–∏ –∑ –≥—ñ–∞–ª—É—Ä–æ–Ω–æ–≤–æ—é –∫–∏—Å–ª–æ—Ç–æ—é",
  "skincare_winter_5": "–†–æ–±—ñ—Ç—å —Ä–µ–≥—É–ª—è—Ä–Ω–æ –ø–æ–∂–∏–≤–Ω—ñ –º–∞—Å–∫–∏",

  "personalized_makeup_base": "–î–ª—è –≤–∞—à–æ–≥–æ —Ç–∏–ø—É –∑–æ–≤–Ω—ñ—à–Ω–æ—Å—Ç—ñ –æ—Å–æ–±–ª–∏–≤–æ –≤–∞–∂–ª–∏–≤–æ: ",
  "personalized_makeup_oval": "–ø—ñ–¥–∫—Ä–µ—Å–ª—é–≤–∞—Ç–∏ –ø—Ä–∏—Ä–æ–¥–Ω—É –≥–∞—Ä–º–æ–Ω—ñ—é —Ä–∏—Å –æ–±–ª–∏—á—á—è",
  "personalized_makeup_round": "—Å—Ç–≤–æ—Ä—é–≤–∞—Ç–∏ –≤—ñ–∑—É–∞–ª—å–Ω—ñ –≤–µ—Ä—Ç–∏–∫–∞–ª—å–Ω—ñ –ª—ñ–Ω—ñ—ó",
  "personalized_makeup_square": "–ø–æ–º'—è–∫—à—É–≤–∞—Ç–∏ –∫—É—Ç–∏ –æ–±–ª–∏—á—á—è",
  "personalized_makeup_heart": "–±–∞–ª–∞–Ω—Å—É–≤–∞—Ç–∏ –≤–µ—Ä—Ö–Ω—é —Ç–∞ –Ω–∏–∂–Ω—é —á–∞—Å—Ç–∏–Ω–∏ –æ–±–ª–∏—á—á—è",
  "personalized_makeup_diamond": "–∞–∫—Ü–µ–Ω—Ç—É–≤–∞—Ç–∏ —Ü–µ–Ω—Ç—Ä –æ–±–ª–∏—á—á—è",
  "personalized_makeup_rectangle": "—Å—Ç–≤–æ—Ä—é–≤–∞—Ç–∏ –≥–∞—Ä–º–æ–Ω—ñ–π–Ω—ñ –ø—Ä–æ–ø–æ—Ä—Ü—ñ—ó",

  "personalized_makeup_spring": "–í–∏–∫–æ—Ä–∏—Å—Ç–æ–≤—É–π—Ç–µ —Ç–µ–ø–ª—ñ, —è—Å–∫—Ä–∞–≤—ñ –≤—ñ–¥—Ç—ñ–Ω–∫–∏ –¥–ª—è —Å–≤—ñ–∂–æ–≥–æ –æ–±—Ä–∞–∑—É",
  "personalized_makeup_summer": "–û–±–∏—Ä–∞–π—Ç–µ –º'—è–∫—ñ, –ø–∞—Å—Ç–µ–ª—å–Ω—ñ —Ç–æ–Ω–∏ –¥–ª—è –ø—Ä–∏—Ä–æ–¥–Ω–æ–≥–æ –º–∞–∫—ñ—è–∂—É",
  "personalized_makeup_autumn": "–í—ñ–¥–¥–∞–≤–∞–π—Ç–µ –ø–µ—Ä–µ–≤–∞–≥—É —Ç–µ–ø–ª–∏–º, –∑–µ–º–ª–∏—Å—Ç–∏–º –≤—ñ–¥—Ç—ñ–Ω–∫–∞–º –¥–ª—è –≥–∞—Ä–º–æ–Ω—ñ–π–Ω–æ–≥–æ –æ–±—Ä–∞–∑—É",
  "personalized_makeup_winter": "–ï–∫—Å–ø–µ—Ä–∏–º–µ–Ω—Ç—É–π—Ç–µ –∑ —è—Å–∫—Ä–∞–≤–∏–º–∏, –∫–æ–Ω—Ç—Ä–∞—Å—Ç–Ω–∏–º–∏ –∫–æ–ª—å–æ—Ä–∞–º–∏ –¥–ª—è –≤–∏—Ä–∞–∑–Ω–æ–≥–æ –º–∞–∫—ñ—è–∂—É",

  "personalized_hair": "–í–∞—à–∞ —Ñ–æ—Ä–º–∞ –æ–±–ª–∏—á—á—è –¥–æ–∑–≤–æ–ª—è—î: ",
  "personalized_hair_oval": "–í–∏ –º–æ–∂–µ—Ç–µ –µ–∫—Å–ø–µ—Ä–∏–º–µ–Ω—Ç—É–≤–∞—Ç–∏ –∑ —Ä—ñ–∑–Ω–∏–º–∏ –∑–∞—á—ñ—Å–∫–∞–º–∏, –æ—Å–∫—ñ–ª—å–∫–∏ –≤–∞—à–∞ —Ñ–æ—Ä–º–∞ –æ–±–ª–∏—á—á—è –º–∞—î –∑–±–∞–ª–∞–Ω—Å–æ–≤–∞–Ω—ñ –ø—Ä–æ–ø–æ—Ä—Ü—ñ—ó",
  "personalized_hair_round": "–û–±–∏—Ä–∞–π—Ç–µ –∑–∞—á—ñ—Å–∫–∏, —â–æ –¥–æ–¥–∞—é—Ç—å –≤–∏—Å–æ—Ç–∏ —Ç–∞ –≤–∏–¥–æ–≤–∂—É—é—Ç—å –æ–±–ª–∏—á—á—è",
  "personalized_hair_square": "–ú'—è–∫—ñ —Ö–≤–∏–ª—ñ —Ç–∞ –±–∞–≥–∞—Ç–æ—à–∞—Ä–æ–≤—ñ —Å—Ç—Ä–∏–∂–∫–∏ –¥–æ–ø–æ–º–æ–∂—É—Ç—å –ø–æ–º'—è–∫—à–∏—Ç–∏ —Ä–∏—Å–∏",
  "personalized_hair_heart": "–ó–∞—á—ñ—Å–∫–∏ –∑ –æ–±'—î–º–æ–º –≤–Ω–∏–∑—É –¥–æ–ø–æ–º–æ–∂—É—Ç—å –∑–±–∞–ª–∞–Ω—Å—É–≤–∞—Ç–∏ –ø—Ä–æ–ø–æ—Ä—Ü—ñ—ó",
  "personalized_hair_diamond": "–î–æ–¥–∞–π—Ç–µ –æ–±'—î–º —É —Å–∫—Ä–æ–Ω–µ–≤—ñ–π –∑–æ–Ω—ñ –∑–∞ –¥–æ–ø–æ–º–æ–≥–æ—é –±–æ–∫–æ–≤–∏—Ö –ø–∞—Å–æ–º",
  "personalized_hair_rectangle": "–ë–∞–≥–∞—Ç–æ—à–∞—Ä–æ–≤—ñ —Å—Ç—Ä–∏–∂–∫–∏ –¥–æ–ø–æ–º–æ–∂—É—Ç—å –¥–æ–¥–∞—Ç–∏ –Ω–µ–æ–±—Ö—ñ–¥–Ω–∏–π –æ–±'—î–º"
}

[FILE: marinette/lib/app/core/theme/app_theme.dart]
import 'package:flutter/material.dart';

class AppTheme {
  static ThemeData get theme => ThemeData(
        primarySwatch: Colors.pink,
        fontFamily: 'PlayfairDisplay',
        useMaterial3: true,
        textTheme: const TextTheme(
          displayLarge: TextStyle(fontFamily: 'PlayfairDisplay'),
          displayMedium: TextStyle(fontFamily: 'PlayfairDisplay'),
          displaySmall: TextStyle(fontFamily: 'PlayfairDisplay'),
          headlineLarge: TextStyle(fontFamily: 'PlayfairDisplay'),
          headlineMedium: TextStyle(fontFamily: 'PlayfairDisplay'),
          headlineSmall: TextStyle(fontFamily: 'PlayfairDisplay'),
          titleLarge: TextStyle(fontFamily: 'PlayfairDisplay'),
          titleMedium: TextStyle(fontFamily: 'PlayfairDisplay'),
          titleSmall: TextStyle(fontFamily: 'PlayfairDisplay'),
          bodyLarge: TextStyle(fontFamily: 'PlayfairDisplay'),
          bodyMedium: TextStyle(fontFamily: 'PlayfairDisplay'),
          bodySmall: TextStyle(fontFamily: 'PlayfairDisplay'),
        ),
        cardTheme: const CardTheme(
          color: Colors.white,
        ),
        elevatedButtonTheme: ElevatedButtonThemeData(
          style: ElevatedButton.styleFrom(
            foregroundColor: Colors.white,
            backgroundColor: Colors.pink,
            textStyle: const TextStyle(
              fontFamily: 'PlayfairDisplay',
              fontWeight: FontWeight.bold,
            ),
          ),
        ),
        outlinedButtonTheme: OutlinedButtonThemeData(
          style: OutlinedButton.styleFrom(
            foregroundColor: Colors.pink,
            textStyle: const TextStyle(
              fontFamily: 'PlayfairDisplay',
              fontWeight: FontWeight.bold,
            ),
          ),
        ),
        appBarTheme: const AppBarTheme(
          backgroundColor: Colors.white,
          foregroundColor: Colors.pink,
          elevation: 0,
          centerTitle: true,
          titleTextStyle: TextStyle(
            fontFamily: 'PlayfairDisplay',
            fontWeight: FontWeight.bold,
            fontSize: 20,
            color: Colors.pink,
          ),
        ),
      );
}

[FILE: marinette/lib/app/core/utils/app_navigation.dart]
import 'package:flutter/material.dart';
import 'package:get/get.dart';

class AppNavigation {
  static Future<T?> navigateTo<T>({
    required BuildContext context,
    required Widget page,
    String? routeName,
  }) {
    return Navigator.of(context).push<T>(
      MaterialPageRoute(
        builder: (context) => page,
        settings: RouteSettings(name: routeName ?? page.runtimeType.toString()),
      ),
    );
  }

  static Future<T?> navigateWithSlide<T>({
    required Widget page,
    bool fullscreenDialog = false,
  }) {
    return Get.to<T>(
          () => page,
          transition: Transition.rightToLeft,
          duration: const Duration(milliseconds: 300),
          fullscreenDialog: fullscreenDialog,
        ) ??
        Future.value(null);
  }

  static void back<T>([T? result]) {
    Get.back<T>(result: result);
  }

  static Future<bool?> showConfirmationDialog({
    required String title,
    required String content,
    String? confirmText,
    String? cancelText,
  }) {
    return Get.dialog<bool>(
      AlertDialog(
        title: Text(title),
        content: Text(content),
        actions: [
          TextButton(
            onPressed: () => Get.back(result: false),
            child: Text(cancelText ?? 'cancel'.tr),
          ),
          TextButton(
            onPressed: () => Get.back(result: true),
            child: Text(
              confirmText ?? 'confirm'.tr,
              style: const TextStyle(color: Colors.red),
            ),
          ),
        ],
      ),
    );
  }
}

[FILE: marinette/lib/app/core/utils/custom_page_route.dart]
import 'package:flutter/material.dart';

class CustomPageRoute<T> extends PageRoute<T> {
  final Widget child;
  @override
  final RouteSettings settings;

  CustomPageRoute({
    required this.child,
    required this.settings,
  });

  @override
  Color? get barrierColor => null;

  @override
  String? get barrierLabel => null;

  @override
  Widget buildPage(BuildContext context, Animation<double> animation,
      Animation<double> secondaryAnimation) {
    return SlideTransition(
      position: Tween<Offset>(
        begin: const Offset(1.0, 0.0),
        end: Offset.zero,
      ).animate(CurvedAnimation(
        parent: animation,
        curve: Curves.easeInOut,
      )),
      child: child,
    );
  }

  @override
  bool get maintainState => true;

  @override
  Duration get transitionDuration => const Duration(milliseconds: 300);

  @override
  Duration get reverseTransitionDuration => const Duration(milliseconds: 300);

  @override
  bool get opaque => true;
}

[FILE: marinette/lib/app/core/utils/page_transitions.dart]
import 'package:flutter/material.dart';

class FadePageRoute extends PageRouteBuilder {
  final Widget page;

  FadePageRoute({required this.page})
      : super(
          pageBuilder: (
            BuildContext context,
            Animation<double> animation,
            Animation<double> secondaryAnimation,
          ) =>
              page,
          transitionsBuilder: (
            BuildContext context,
            Animation<double> animation,
            Animation<double> secondaryAnimation,
            Widget child,
          ) =>
              FadeTransition(
            opacity: animation,
            child: child,
          ),
        );
}

class SlidePageRoute extends PageRouteBuilder {
  final Widget page;
  final SlideDirection direction;

  SlidePageRoute({
    required this.page,
    this.direction = SlideDirection.right,
  }) : super(
          pageBuilder: (
            BuildContext context,
            Animation<double> animation,
            Animation<double> secondaryAnimation,
          ) =>
              page,
          transitionsBuilder: (
            BuildContext context,
            Animation<double> animation,
            Animation<double> secondaryAnimation,
            Widget child,
          ) {
            Offset begin;
            switch (direction) {
              case SlideDirection.right:
                begin = const Offset(1.0, 0.0);
                break;
              case SlideDirection.left:
                begin = const Offset(-1.0, 0.0);
                break;
              case SlideDirection.up:
                begin = const Offset(0.0, 1.0);
                break;
              case SlideDirection.down:
                begin = const Offset(0.0, -1.0);
                break;
            }

            return SlideTransition(
              position: Tween<Offset>(
                begin: begin,
                end: Offset.zero,
              ).animate(CurvedAnimation(
                parent: animation,
                curve: Curves.easeInOut,
              )),
              child: child,
            );
          },
        );
}

enum SlideDirection {
  right,
  left,
  up,
  down,
}

[FILE: marinette/lib/app/core/widgets/wave_background_painter.dart]
import 'package:flutter/material.dart';

class WaveBackgroundPainter extends CustomPainter {
  @override
  void paint(Canvas canvas, Size size) {
    final paint = Paint()
      ..color = Colors.pink.withOpacity(0.1)
      ..style = PaintingStyle.fill;

    final path = Path();

    // –ü–æ—á–∞—Ç–∫–æ–≤–∞ —Ç–æ—á–∫–∞
    path.moveTo(0, size.height * 0.3);

    // –ü–µ—Ä—à–∞ —Ö–≤–∏–ª—è
    path.quadraticBezierTo(
      size.width * 0.25,
      size.height * 0.35,
      size.width * 0.5,
      size.height * 0.3,
    );

    // –î—Ä—É–≥–∞ —Ö–≤–∏–ª—è
    path.quadraticBezierTo(
      size.width * 0.75,
      size.height * 0.25,
      size.width,
      size.height * 0.3,
    );

    // –ó–∞–≤–µ—Ä—à–µ–Ω–Ω—è —à–ª—è—Ö—É
    path.lineTo(size.width, size.height);
    path.lineTo(0, size.height);
    path.close();

    canvas.drawPath(path, paint);
  }

  @override
  bool shouldRepaint(CustomPainter oldDelegate) => false;
}

[FILE: marinette/lib/app/data/content/beauty_trends.dart]
class BeautyTrend {
  final String title;
  final String description;
  final String season; // 'winter', 'spring', 'summer', 'autumn'

  const BeautyTrend({
    required this.title,
    required this.description,
    required this.season,
  });
}

const List<BeautyTrend> beautyTrends = [
  // Spring Trends
  BeautyTrend(
    title: 'Glass Skin',
    description: 'Achieve that dewy, transparent complexion',
    season: 'spring',
  ),
  BeautyTrend(
    title: 'Pastel Eyeshadows',
    description: 'Light, airy colors for a fresh spring look',
    season: 'spring',
  ),
  BeautyTrend(
    title: 'Natural Blush',
    description: 'Soft, rosy cheeks for springtime glow',
    season: 'spring',
  ),

  // Summer Trends
  BeautyTrend(
    title: 'Sunburnt Blush',
    description: 'The perfect summer flush across the nose and cheeks',
    season: 'summer',
  ),
  BeautyTrend(
    title: 'Glazed Skin',
    description: 'Dewy, hydrated skin with a glossy finish',
    season: 'summer',
  ),
  BeautyTrend(
    title: 'Waterproof Makeup',
    description: 'Long-lasting looks for hot summer days',
    season: 'summer',
  ),

  // Autumn Trends
  BeautyTrend(
    title: 'Soft Matte Skin',
    description: 'Velvet-like finish for autumn sophistication',
    season: 'autumn',
  ),
  BeautyTrend(
    title: 'Berry Lips',
    description: 'Deep, rich colors for fall season',
    season: 'autumn',
  ),
  BeautyTrend(
    title: 'Copper Eyes',
    description: 'Warm metallic shades for autumn glow',
    season: 'autumn',
  ),

  // Winter Trends
  BeautyTrend(
    title: 'Glossy Lips',
    description: 'Hydrated, plump lips for winter days',
    season: 'winter',
  ),
  BeautyTrend(
    title: 'Frosted Looks',
    description: 'Shimmering finishes for winter magic',
    season: 'winter',
  ),
  BeautyTrend(
    title: 'Rich Hydration',
    description: 'Deep moisturizing for winter protection',
    season: 'winter',
  ),
];

[FILE: marinette/lib/app/data/content/daily_tips.dart]
class DailyTip {
  final String tip;
  final String icon;

  const DailyTip({
    required this.tip,
    this.icon = 'üí°',
  });
}

const List<DailyTip> dailyTips = [
  DailyTip(
    tip:
        'Use ice cube therapy in the morning to reduce puffiness and give your skin a natural glow',
    icon: '‚ùÑÔ∏è',
  ),
  DailyTip(
    tip:
        'Apply your skincare products from thinnest to thickest consistency for better absorption',
    icon: 'üß¥',
  ),
  DailyTip(
    tip:
        'Protect your skin with SPF even on cloudy days to prevent premature aging',
    icon: '‚òÄÔ∏è',
  ),
  DailyTip(
    tip: 'Stay hydrated! Drink plenty of water for a natural, healthy glow',
    icon: 'üíß',
  ),
  DailyTip(
    tip: 'Clean your makeup brushes regularly to prevent breakouts',
    icon: 'üñåÔ∏è',
  ),
  DailyTip(
    tip: 'Get your beauty sleep! 7-8 hours of sleep helps skin regeneration',
    icon: 'üò¥',
  ),
  DailyTip(
    tip: 'Pat, don\'t rub! Be gentle when applying products around your eyes',
    icon: 'üëÅÔ∏è',
  ),
  DailyTip(
    tip: 'Use a silk pillowcase to prevent hair breakage and skin creasing',
    icon: 'üõèÔ∏è',
  ),
  DailyTip(
    tip: 'Apply face masks on clean, exfoliated skin for better results',
    icon: 'üé≠',
  ),
  DailyTip(
    tip: 'Don\'t forget your neck when applying skincare products',
    icon: '‚ú®',
  ),
];

[FILE: marinette/lib/app/data/models/face_analysis_result.dart]
class FaceAnalysisResult {
  final String faceShape;
  final String colorType;
  final List<String> makeupRecommendations;
  final List<String> hairstyleRecommendations;
  final List<String> skincareRecommendations;

  FaceAnalysisResult({
    required this.faceShape,
    required this.colorType,
    required this.makeupRecommendations,
    required this.hairstyleRecommendations,
    required this.skincareRecommendations,
  });
}

[FILE: marinette/lib/app/data/models/facial_features.dart]
import 'dart:math' show Point;

class FacialFeatures {
  final double symmetry;
  final double faceWidth;
  final double faceHeight;
  final double jawlineStrength;
  final double cheekboneProminence;
  final double foreheadHeight;
  final List<Point<int>> facialContours;

  FacialFeatures({
    required this.symmetry,
    required this.faceWidth,
    required this.faceHeight,
    required this.jawlineStrength,
    required this.cheekboneProminence,
    required this.foreheadHeight,
    required this.facialContours,
  });
}

[FILE: marinette/lib/app/data/services/audio_service.dart]
import 'package:get/get.dart';
import 'package:just_audio/just_audio.dart';
import 'package:marinette/app/data/services/user_preferences_service.dart';
import 'package:flutter/foundation.dart' show debugPrint;

class AudioService extends GetxService {
  AudioPlayer? _player;
  final _isPlaying = false.obs;
  final _isMuted = false.obs;
  final _isInitialized = false.obs;
  final UserPreferencesService _prefs = Get.find<UserPreferencesService>();

  static const String _bgMusicPath = 'assets/audio/nana.mp3';
  static const String _isMusicEnabledKey = 'is_music_enabled';
  static const double _defaultVolume =
      0.3; // –ó–º–µ–Ω—à–∏–ª–∏ –≥—É—á–Ω—ñ—Å—Ç—å –∑–∞ –∑–∞–º–æ–≤—á—É–≤–∞–Ω–Ω—è–º

  Future<AudioService> init() async {
    try {
      _player = AudioPlayer();

      // –ù–∞–ª–∞—à—Ç–æ–≤—É—î–º–æ –∞—É–¥—ñ–æ –∑ –æ–±—Ä–æ–±–∫–æ—é –ø–æ–º–∏–ª–æ–∫
      try {
        await _player?.setAsset(_bgMusicPath);
        await _player?.setLoopMode(LoopMode.all);
        await _player?.setVolume(_defaultVolume);
        _isInitialized.value = true;

        // –í—ñ–¥–Ω–æ–≤–ª—é—î–º–æ –æ—Å—Ç–∞–Ω–Ω—ñ–π —Å—Ç–∞–Ω –º—É–∑–∏–∫–∏
        final isMusicEnabled = await _prefs.getBool(_isMusicEnabledKey) ?? true;
        if (isMusicEnabled) {
          await play();
        }
      } catch (e) {
        debugPrint('Error configuring audio player: $e');
        _isInitialized.value = false;
      }
    } catch (e) {
      debugPrint('Error creating audio player: $e');
      _isInitialized.value = false;
    }
    return this;
  }

  bool get isPlaying => _isPlaying.value;
  bool get isMuted => _isMuted.value;
  bool get isInitialized => _isInitialized.value;

  Future<void> play() async {
    if (!_isInitialized.value || _player == null) return;

    try {
      await _player?.play();
      _isPlaying.value = true;
      await _prefs.setBool(_isMusicEnabledKey, true);
    } catch (e) {
      debugPrint('Error playing music: $e');
    }
  }

  Future<void> pause() async {
    if (!_isInitialized.value || _player == null) return;

    try {
      await _player?.pause();
      _isPlaying.value = false;
      await _prefs.setBool(_isMusicEnabledKey, false);
    } catch (e) {
      debugPrint('Error pausing music: $e');
    }
  }

  Future<void> toggle() async {
    if (!_isInitialized.value) return;

    if (_isPlaying.value) {
      await pause();
    } else {
      await play();
    }
  }

  Future<void> mute() async {
    if (!_isInitialized.value || _player == null) return;

    try {
      await _player?.setVolume(0);
      _isMuted.value = true;
    } catch (e) {
      debugPrint('Error muting music: $e');
    }
  }

  Future<void> unmute() async {
    if (!_isInitialized.value || _player == null) return;

    try {
      await _player?.setVolume(_defaultVolume);
      _isMuted.value = false;
    } catch (e) {
      debugPrint('Error unmuting music: $e');
    }
  }

  Future<void> toggleMute() async {
    if (!_isInitialized.value) return;

    if (_isMuted.value) {
      await unmute();
    } else {
      await mute();
    }
  }

  Future<void> setVolume(double volume) async {
    if (!_isInitialized.value || _player == null) return;

    try {
      await _player?.setVolume(volume);
      _isMuted.value = volume == 0;
    } catch (e) {
      debugPrint('Error setting volume: $e');
    }
  }

  @override
  void onClose() {
    _player?.dispose();
    super.onClose();
  }
}

[FILE: marinette/lib/app/data/services/color_type_analyzer.dart]
import 'package:google_mlkit_face_detection/google_mlkit_face_detection.dart';
import 'package:marinette/app/data/services/skin_color_analyzer.dart';

enum ColorType {
  spring, // –¢–µ–ø–ª–µ-—è—Å–∫—Ä–∞–≤–µ
  summer, // –•–æ–ª–æ–¥–Ω–µ-–º'—è–∫–µ
  autumn, // –¢–µ–ø–ª–µ-–º'—è–∫–µ
  winter, // –•–æ–ª–æ–¥–Ω–µ-—è—Å–∫—Ä–∞–≤–µ
}

class ColorTypeAnalyzer {
  static Future<ColorType> analyzeColorType(String imagePath, Face face) async {
    try {
      final skinTone = await SkinColorAnalyzer.analyzeSkinTone(imagePath, face);

      // –í–∏–∑–Ω–∞—á–∞—î–º–æ –∫–æ–ª—å–æ—Ä–æ—Ç–∏–ø –Ω–∞ –æ—Å–Ω–æ–≤—ñ —Ö–∞—Ä–∞–∫—Ç–µ—Ä–∏—Å—Ç–∏–∫ –∫–æ–ª—å–æ—Ä—É —à–∫—ñ—Ä–∏
      bool isWarm = skinTone.warmth > 0.5;
      bool isBright = skinTone.saturation > 0.4;
      bool isLight = skinTone.lightness > 0.5;

      // –û—Å–Ω–æ–≤–Ω–∞ –ª–æ–≥—ñ–∫–∞ –≤–∏–∑–Ω–∞—á–µ–Ω–Ω—è –∫–æ–ª—å–æ—Ä–æ—Ç–∏–ø—É:
      if (isWarm) {
        // –¢–µ–ø–ª—ñ –∫–æ–ª—å–æ—Ä–æ—Ç–∏–ø–∏
        if (isBright && isLight) {
          return ColorType.spring; // –¢–µ–ø–ª–µ-—è—Å–∫—Ä–∞–≤–µ
        } else {
          return ColorType.autumn; // –¢–µ–ø–ª–µ-–º'—è–∫–µ
        }
      } else {
        // –•–æ–ª–æ–¥–Ω—ñ –∫–æ–ª—å–æ—Ä–æ—Ç–∏–ø–∏
        if (isBright) {
          return ColorType.winter; // –•–æ–ª–æ–¥–Ω–µ-—è—Å–∫—Ä–∞–≤–µ
        } else {
          return ColorType.summer; // –•–æ–ª–æ–¥–Ω–µ-–º'—è–∫–µ
        }
      }
    } catch (e) {
      // –£ –≤–∏–ø–∞–¥–∫—É –ø–æ–º–∏–ª–∫–∏ –ø–æ–≤–µ—Ä—Ç–∞—î–º–æ spring —è–∫ –Ω–∞–π–±—ñ–ª—å—à —É–Ω—ñ–≤–µ—Ä—Å–∞–ª—å–Ω–∏–π —Ç–∏–ø
      return ColorType.spring;
    }
  }

  static Map<String, List<String>> getColorPalette(ColorType colorType) {
    switch (colorType) {
      case ColorType.spring:
        return {
          '–æ—Å–Ω–æ–≤–Ω—ñ': ['–¢–µ–ø–ª–∏–π –∂–æ–≤—Ç–∏–π', '–ö–æ—Ä–∞–ª–æ–≤–∏–π', '–ü–µ—Ä—Å–∏–∫–æ–≤–∏–π', '–ó–æ–ª–æ—Ç–∏—Å—Ç–∏–π'],
          '–∞–∫—Ü–µ–Ω—Ç–Ω—ñ': ['–Ø—Å–∫—Ä–∞–≤–æ-–∑–µ–ª–µ–Ω–∏–π', '–ë—ñ—Ä—é–∑–æ–≤–∏–π', '–°–≤—ñ—Ç–ª–æ-—Ä–æ–∂–µ–≤–∏–π'],
          '—É–Ω–∏–∫–∞—Ç–∏': ['–ß–æ—Ä–Ω–∏–π', '–°—ñ—Ä–∏–π', '–ü—Ä–∏–≥–ª—É—à–µ–Ω—ñ —Ö–æ–ª–æ–¥–Ω—ñ –≤—ñ–¥—Ç—ñ–Ω–∫–∏'],
        };
      case ColorType.summer:
        return {
          '–æ—Å–Ω–æ–≤–Ω—ñ': ['–•–æ–ª–æ–¥–Ω–∏–π —Ä–æ–∂–µ–≤–∏–π', '–õ–∞–≤–∞–Ω–¥–æ–≤–∏–π', '–ë–ª–∞–∫–∏—Ç–Ω–∏–π', '–°—ñ—Ä–∏–π'],
          '–∞–∫—Ü–µ–Ω—Ç–Ω—ñ': ['–ú\'—è—Ç–∞', '–ë—É–∑–∫–æ–≤–∏–π', '–°—Ä—ñ–±–ª—è—Å—Ç–∏–π'],
          '—É–Ω–∏–∫–∞—Ç–∏': ['–ü–æ–º–∞—Ä–∞–Ω—á–µ–≤–∏–π', '–ö–æ—Ä–∏—á–Ω–µ–≤–∏–π', '–Ø—Å–∫—Ä–∞–≤—ñ —Ç–µ–ø–ª—ñ –≤—ñ–¥—Ç—ñ–Ω–∫–∏'],
        };
      case ColorType.autumn:
        return {
          '–æ—Å–Ω–æ–≤–Ω—ñ': ['–¢–µ—Ä–∞–∫–æ—Ç–æ–≤–∏–π', '–•–∞–∫—ñ', '–ì—ñ—Ä—á–∏—á–Ω–∏–π', '–ö–æ—Ä–∏—á–Ω–µ–≤–∏–π'],
          '–∞–∫—Ü–µ–Ω—Ç–Ω—ñ': ['–ë—Ä–æ–Ω–∑–æ–≤–∏–π', '–û–ª–∏–≤–∫–æ–≤–∏–π', '–ú—ñ–¥–Ω–∏–π'],
          '—É–Ω–∏–∫–∞—Ç–∏': ['–Ø—Å–∫—Ä–∞–≤–æ-—Ä–æ–∂–µ–≤–∏–π', '–°—Ä—ñ–±–ª—è—Å—Ç–∏–π', '–•–æ–ª–æ–¥–Ω—ñ –ø–∞—Å—Ç–µ–ª—å–Ω—ñ'],
        };
      case ColorType.winter:
        return {
          '–æ—Å–Ω–æ–≤–Ω—ñ': ['–ß–∏—Å—Ç–∏–π –±—ñ–ª–∏–π', '–ß–æ—Ä–Ω–∏–π', '–¢–µ–º–Ω–æ-—Å–∏–Ω—ñ–π', '–°–∞–ø—Ñ—ñ—Ä–æ–≤–∏–π'],
          '–∞–∫—Ü–µ–Ω—Ç–Ω—ñ': ['–°–º–∞—Ä–∞–≥–¥–æ–≤–∏–π', '–§—É–∫—Å—ñ—è', '–Ø—Å–∫—Ä–∞–≤–æ-—á–µ—Ä–≤–æ–Ω–∏–π'],
          '—É–Ω–∏–∫–∞—Ç–∏': ['–ë–µ–∂–µ–≤–∏–π', '–ü–æ–º–∞—Ä–∞–Ω—á–µ–≤–∏–π', '–ü—Ä–∏–≥–ª—É—à–µ–Ω—ñ —Ç–µ–ø–ª—ñ –≤—ñ–¥—Ç—ñ–Ω–∫–∏'],
        };
    }
  }

  static Map<String, List<String>> getMakeupColors(ColorType colorType) {
    switch (colorType) {
      case ColorType.spring:
        return {
          '–ø–æ–º–∞–¥–∞': ['–ö–æ—Ä–∞–ª–æ–≤–∏–π', '–ü–µ—Ä—Å–∏–∫–æ–≤–∏–π', '–¢–µ–ø–ª–∏–π —Ä–æ–∂–µ–≤–∏–π'],
          '—Ä—É–º\'—è–Ω–∞': ['–ü–µ—Ä—Å–∏–∫–æ–≤–∏–π', '–ê–±—Ä–∏–∫–æ—Å–æ–≤–∏–π', '–ó–æ–ª–æ—Ç–∏—Å—Ç–∏–π'],
          '—Ç—ñ–Ω—ñ': ['–ó–æ–ª–æ—Ç–∏—Å—Ç–æ-–∫–æ—Ä–∏—á–Ω–µ–≤–∏–π', '–ë—Ä–æ–Ω–∑–æ–≤–∏–π', '–¢–µ–ø–ª–∏–π –∑–µ–ª–µ–Ω–∏–π'],
        };
      case ColorType.summer:
        return {
          '–ø–æ–º–∞–¥–∞': ['–•–æ–ª–æ–¥–Ω–∏–π —Ä–æ–∂–µ–≤–∏–π', '–ú–∞–ª–∏–Ω–æ–≤–∏–π', '–°–ª–∏–≤–æ–≤–∏–π'],
          '—Ä—É–º\'—è–Ω–∞': ['–†–æ–∂–µ–≤–∏–π', '–õ–∞–≤–∞–Ω–¥–æ–≤–∏–π', '–°–≤—ñ—Ç–ª–æ-–º–∞–ª–∏–Ω–æ–≤–∏–π'],
          '—Ç—ñ–Ω—ñ': ['–°—ñ—Ä–∏–π', '–ë–ª–∞–∫–∏—Ç–Ω–∏–π', '–†–æ–∂–µ–≤–æ-–∫–æ—Ä–∏—á–Ω–µ–≤–∏–π'],
        };
      case ColorType.autumn:
        return {
          '–ø–æ–º–∞–¥–∞': ['–¢–µ—Ä–∞–∫–æ—Ç–æ–≤–∏–π', '–ú—ñ–¥–Ω–∏–π', '–ö–æ—Ä–∏—á–Ω–µ–≤–∏–π'],
          '—Ä—É–º\'—è–Ω–∞': ['–¢–µ—Ä–∞–∫–æ—Ç–æ–≤–∏–π', '–ë—Ä–æ–Ω–∑–æ–≤–∏–π', '–¢–µ–ø–ª–∏–π –∫–æ—Ä–∏—á–Ω–µ–≤–∏–π'],
          '—Ç—ñ–Ω—ñ': ['–ó–æ–ª–æ—Ç–∏—Å—Ç–æ-–∫–æ—Ä–∏—á–Ω–µ–≤–∏–π', '–•–∞–∫—ñ', '–ú—ñ–¥–Ω–∏–π'],
        };
      case ColorType.winter:
        return {
          '–ø–æ–º–∞–¥–∞': ['–Ø—Å–∫—Ä–∞–≤–æ-—á–µ—Ä–≤–æ–Ω–∏–π', '–§—É–∫—Å—ñ—è', '–ë–æ—Ä–¥–æ–≤–∏–π'],
          '—Ä—É–º\'—è–Ω–∞': ['–•–æ–ª–æ–¥–Ω–∏–π —Ä–æ–∂–µ–≤–∏–π', '–í–∏—à–Ω–µ–≤–∏–π', '–ú–∞–ª–∏–Ω–æ–≤–∏–π'],
          '—Ç—ñ–Ω—ñ': ['–î–∏–º—á–∞—Å—Ç–∏–π', '–°–∏–Ω—ñ–π', '–°—Ä—ñ–±–ª—è—Å—Ç–∏–π'],
        };
    }
  }
}

[FILE: marinette/lib/app/data/services/content_service.dart]
import 'package:get/get.dart';
import 'package:marinette/app/data/content/daily_tips.dart';
import 'package:marinette/app/data/content/beauty_trends.dart';

class ContentService extends GetxService {
  final Rx<DailyTip> currentTip = dailyTips[0].obs;
  final RxList<BeautyTrend> currentTrends = <BeautyTrend>[].obs;

  Future<ContentService> init() async {
    updateDailyTip();
    updateSeasonalTrends();
    return this;
  }

  void updateDailyTip() {
    final dayOfYear =
        DateTime.now().difference(DateTime(DateTime.now().year)).inDays;
    final tipIndex = dayOfYear % dailyTips.length;
    currentTip.value = dailyTips[tipIndex];
  }

  void updateSeasonalTrends() {
    final currentMonth = DateTime.now().month;
    String season;

    if (currentMonth >= 3 && currentMonth <= 5) {
      season = 'spring';
    } else if (currentMonth >= 6 && currentMonth <= 8) {
      season = 'summer';
    } else if (currentMonth >= 9 && currentMonth <= 11) {
      season = 'autumn';
    } else {
      season = 'winter';
    }

    final seasonalTrends =
        beautyTrends.where((trend) => trend.season == season).toList();
    currentTrends.value = seasonalTrends;
  }
}

[FILE: marinette/lib/app/data/services/face_analysis_service.dart]
import 'dart:io';
import 'dart:typed_data';
import 'package:flutter/material.dart';
import 'package:flutter/foundation.dart' show kIsWeb;
import 'package:google_mlkit_face_detection/google_mlkit_face_detection.dart';
import 'package:get/get.dart';
import 'package:image_picker/image_picker.dart';
import 'package:marinette/app/data/models/face_analysis_result.dart';
import 'package:marinette/app/data/services/face_shape_analyzer.dart';
import 'package:marinette/app/data/services/color_type_analyzer.dart';
import 'package:marinette/app/data/services/recommendations_service.dart';

class FaceAnalysisService extends GetxService {
  final FaceDetector _faceDetector = FaceDetector(
    options: FaceDetectorOptions(
      enableContours: true,
      enableLandmarks: true,
      performanceMode: FaceDetectorMode.accurate,
    ),
  );

  Future<FaceAnalysisResult?> analyzeFace(String imagePath) async {
    debugPrint('Starting face analysis for: $imagePath');
    try {
      late InputImage inputImage;

      if (kIsWeb) {
        // –û—Ç—Ä–∏–º—É—î–º–æ XFile –¥–ª—è –≤–µ–±
        final XFile pickedFile = XFile(imagePath);
        final Uint8List bytes = await pickedFile.readAsBytes();
        inputImage = InputImage.fromBytes(
          bytes: bytes,
          metadata: InputImageMetadata(
            size: const Size(800, 600), // –ü—Ä–∏–±–ª–∏–∑–Ω–∏–π —Ä–æ–∑–º—ñ—Ä
            rotation: InputImageRotation.rotation0deg,
            format: InputImageFormat.bgra8888,
            bytesPerRow: 800 * 4, // width * 4 bytes per pixel
          ),
        );
      } else {
        // –î–ª—è –º–æ–±—ñ–ª—å–Ω–æ—ó –≤–µ—Ä—Å—ñ—ó
        final File imageFile = File(imagePath);
        inputImage = InputImage.fromFile(imageFile);
      }

      debugPrint('Processing image with ML Kit');
      final faces = await _faceDetector.processImage(inputImage);
      debugPrint('Found ${faces.length} faces');

      if (faces.isEmpty) {
        debugPrint('No faces detected');
        Get.snackbar('error'.tr, 'error_no_face'.tr);
        return null;
      }

      if (faces.length > 1) {
        debugPrint('Multiple faces detected');
        Get.snackbar('error'.tr, 'error_multiple_faces'.tr);
        return null;
      }

      final face = faces.first;
      debugPrint('Analyzing single face');

      // –í–∏–∑–Ω–∞—á–µ–Ω–Ω—è —Ñ–æ—Ä–º–∏ –æ–±–ª–∏—á—á—è
      final faceShape = FaceShapeAnalyzer.analyzeFaceShape(face);
      debugPrint('Face shape determined: $faceShape');

      // –í–∏–∑–Ω–∞—á–µ–Ω–Ω—è –∫–æ–ª—å–æ—Ä–æ—Ç–∏–ø—É
      final colorType =
          await ColorTypeAnalyzer.analyzeColorType(imagePath, face);
      debugPrint('Color type determined: $colorType');

      // –û—Ç—Ä–∏–º–∞–Ω–Ω—è —Ä–µ–∫–æ–º–µ–Ω–¥–∞—Ü—ñ–π
      debugPrint('Generating recommendations');
      final makeupRecommendations =
          RecommendationsService.getMakeupRecommendations(faceShape, colorType);
      final hairstyleRecommendations =
          RecommendationsService.getHairstyleRecommendations(
              faceShape, colorType);
      final skincareRecommendations =
          RecommendationsService.getSkincareRecommendations(colorType);

      // –û—Ç—Ä–∏–º–∞–Ω–Ω—è –ø–µ—Ä—Å–æ–Ω–∞–ª—ñ–∑–æ–≤–∞–Ω–∏—Ö –ø–æ—Ä–∞–¥
      final personalTips = RecommendationsService.getPersonalizedTips(
        faceShape: faceShape,
        colorType: colorType,
      );

      // –î–æ–¥–∞—î–º–æ —Å–µ–∑–æ–Ω–Ω—É —Ä–µ–∫–æ–º–µ–Ω–¥–∞—Ü—ñ—é
      final seasonalTip = RecommendationsService.getSeasonalRecommendation();

      // –û–±'—î–¥–Ω—É—î–º–æ –≤—Å—ñ —Ä–µ–∫–æ–º–µ–Ω–¥–∞—Ü—ñ—ó
      return FaceAnalysisResult(
        faceShape: _getFaceShapeName(faceShape),
        colorType: _getColorTypeName(colorType),
        makeupRecommendations: [
          ...makeupRecommendations,
          personalTips[0]
        ], // –î–æ–¥–∞—î–º–æ –ø–µ—Ä—Å–æ–Ω–∞–ª—ñ–∑–æ–≤–∞–Ω—É –ø–æ—Ä–∞–¥—É –ø–æ –º–∞–∫—ñ—è–∂—É
        hairstyleRecommendations: [
          ...hairstyleRecommendations,
          personalTips[1]
        ], // –î–æ–¥–∞—î–º–æ –ø–æ—Ä–∞–¥—É –ø–æ –≤–æ–ª–æ—Å—Å—é
        skincareRecommendations: [
          ...skincareRecommendations,
          seasonalTip
        ], // –î–æ–¥–∞—î–º–æ —Å–µ–∑–æ–Ω–Ω—É –ø–æ—Ä–∞–¥—É
      );
    } catch (e, stackTrace) {
      debugPrint('Error during analysis: $e');
      debugPrint('Stack trace: $stackTrace');
      Get.snackbar('error'.tr, 'error_analyzing'.tr);
      return null;
    }
  }

  String _getFaceShapeName(FaceShape shape) {
    switch (shape) {
      case FaceShape.oval:
        return 'face_shape_oval'.tr;
      case FaceShape.round:
        return 'face_shape_round'.tr;
      case FaceShape.square:
        return 'face_shape_square'.tr;
      case FaceShape.heart:
        return 'face_shape_heart'.tr;
      case FaceShape.diamond:
        return 'face_shape_diamond'.tr;
      case FaceShape.rectangle:
        return 'face_shape_rectangle'.tr;
    }
  }

  String _getColorTypeName(ColorType type) {
    switch (type) {
      case ColorType.spring:
        return 'color_type_spring'.tr;
      case ColorType.summer:
        return 'color_type_summer'.tr;
      case ColorType.autumn:
        return 'color_type_autumn'.tr;
      case ColorType.winter:
        return 'color_type_winter'.tr;
    }
  }

  @override
  void onClose() {
    _faceDetector.close();
    super.onClose();
  }
}

[FILE: marinette/lib/app/data/services/face_shape_analyzer.dart]
import 'package:google_mlkit_face_detection/google_mlkit_face_detection.dart';
import 'dart:math' show Point;

enum FaceShape {
  oval,
  round,
  square,
  heart,
  diamond,
  rectangle,
}

class FaceShapeAnalyzer {
  static FaceShape analyzeFaceShape(Face face) {
    final double faceWidth = face.boundingBox.width;
    final double faceHeight = face.boundingBox.height;
    final double ratio = faceHeight / faceWidth;

    // –û—Ç—Ä–∏–º—É—î–º–æ –∫–æ–Ω—Ç—É—Ä–∏ –æ–±–ª–∏—á—á—è
    final faceContour = face.contours[FaceContourType.face];
    if (faceContour == null) return FaceShape.oval;

    // –ê–Ω–∞–ª—ñ–∑ —Ñ–æ—Ä–º–∏ –Ω–∞ –æ—Å–Ω–æ–≤—ñ —Å–ø—ñ–≤–≤—ñ–¥–Ω–æ—à–µ–Ω—å —Ç–∞ –∫–æ–Ω—Ç—É—Ä—ñ–≤
    if (ratio > 1.5) {
      return _analyzeElongatedFace(faceContour);
    } else if (ratio < 1.2) {
      return _analyzeWideFace(faceContour);
    } else {
      return _analyzeMediumFace(faceContour);
    }
  }

  static FaceShape _analyzeElongatedFace(FaceContour contour) {
    // –ê–Ω–∞–ª—ñ–∑ –≤–µ—Ä—Ö–Ω—å–æ—ó —á–∞—Å—Ç–∏–Ω–∏ –æ–±–ª–∏—á—á—è
    double topWidth = _getWidthAtPosition(contour.points, 0.2);
    double bottomWidth = _getWidthAtPosition(contour.points, 0.8);

    if (topWidth < bottomWidth * 0.85) {
      return FaceShape.heart;
    } else if (topWidth > bottomWidth * 1.15) {
      return FaceShape.diamond;
    }

    return FaceShape.oval;
  }

  static FaceShape _analyzeWideFace(FaceContour contour) {
    // –ê–Ω–∞–ª—ñ–∑ –∫—É—Ç—ñ–≤ —â–µ–ª–µ–ø–∏
    double jawAngle = _calculateJawAngle(contour.points);

    if (jawAngle > 80) {
      return FaceShape.square;
    }

    return FaceShape.round;
  }

  static FaceShape _analyzeMediumFace(FaceContour contour) {
    // –ê–Ω–∞–ª—ñ–∑ –ø—Ä–æ–ø–æ—Ä—Ü—ñ–π —Å–µ—Ä–µ–¥–Ω—å–æ—ó —á–∞—Å—Ç–∏–Ω–∏ –æ–±–ª–∏—á—á—è
    double middleWidth = _getWidthAtPosition(contour.points, 0.5);
    double topWidth = _getWidthAtPosition(contour.points, 0.2);

    if (middleWidth > topWidth * 1.1) {
      return FaceShape.rectangle;
    }

    return FaceShape.oval;
  }

  static double _getWidthAtPosition(
      List<Point<int>> points, double heightPercent) {
    if (points.isEmpty) return 0;

    final firstPoint = points.first;
    final lastPoint = points.last;

    int targetY =
        (firstPoint.y + (lastPoint.y - firstPoint.y) * heightPercent).round();

    var pointsAtHeight =
        points.where((p) => (p.y - targetY).abs() < 5).toList();

    if (pointsAtHeight.isEmpty) return 0;

    var xValues = pointsAtHeight.map((p) => p.x).toList();

    double minX = xValues.reduce((a, b) => a < b ? a : b).toDouble();
    double maxX = xValues.reduce((a, b) => a > b ? a : b).toDouble();

    return maxX - minX;
  }

  static double _calculateJawAngle(List<Point<int>> points) {
    if (points.length < 3) return 90;

    // –°–ø—Ä–æ—â–µ–Ω–∏–π —Ä–æ–∑—Ä–∞—Ö—É–Ω–æ–∫ –∫—É—Ç–∞ —â–µ–ª–µ–ø–∏
    var bottomPoints = points.where((p) {
      var maxY = points.map((p) => p.y).reduce((a, b) => a > b ? a : b);
      return p.y > maxY - 20;
    }).toList();

    if (bottomPoints.length < 3) return 90;

    var sorted = bottomPoints..sort((a, b) => a.x.compareTo(b.x));
    var first = sorted.first;
    var last = sorted.last;
    var middle = sorted[sorted.length ~/ 2];

    // –†–æ–∑—Ä–∞—Ö—É–Ω–æ–∫ –∫—É—Ç–∞ –º—ñ–∂ —Ç—Ä—å–æ–º–∞ —Ç–æ—á–∫–∞–º–∏
    double dx1 = (first.x - middle.x).toDouble();
    double dy1 = (first.y - middle.y).toDouble();
    double dx2 = (last.x - middle.x).toDouble();
    double dy2 = (last.y - middle.y).toDouble();

    double dotProduct = dx1 * dx2 + dy1 * dy2;
    double magnitude1 = sqrt(dx1 * dx1 + dy1 * dy1);
    double magnitude2 = sqrt(dx2 * dx2 + dy2 * dy2);

    if (magnitude1 == 0 || magnitude2 == 0) return 90;

    return (180 / 3.14159) * (dotProduct / (magnitude1 * magnitude2));
  }

  static double sqrt(double x) => x <= 0 ? 0 : x.roundToDouble();
}

[FILE: marinette/lib/app/data/services/facial_features_analyzer.dart]
import 'package:google_mlkit_face_detection/google_mlkit_face_detection.dart';
import 'dart:math' show Point, min, max, sqrt, pow, atan2, pi;
import 'package:marinette/app/data/models/facial_features.dart';

class FacialFeaturesAnalyzer {
  static Future<FacialFeatures> analyzeFace(Face face) async {
    final faceContour = face.contours[FaceContourType.face];
    if (faceContour == null) {
      throw Exception('Face contour not detected');
    }

    final points = faceContour.points;

    // –ê–Ω–∞–ª—ñ–∑ —Å–∏–º–µ—Ç—Ä—ñ—ó
    final symmetry = _calculateSymmetry(points);

    // –û—Å–Ω–æ–≤–Ω—ñ –≤–∏–º—ñ—Ä–∏
    final faceWidth = face.boundingBox.width;
    final faceHeight = face.boundingBox.height;

    // –ê–Ω–∞–ª—ñ–∑ —â–µ–ª–µ–ø–∏
    final jawlineStrength = _analyzeJawline(face);

    // –ê–Ω–∞–ª—ñ–∑ –≤–∏–ª–∏—Ü—å
    final cheekboneProminence = _analyzeCheekbones(face);

    // –ê–Ω–∞–ª—ñ–∑ —á–æ–ª–∞
    final foreheadHeight = _analyzeForeheadHeight(face);

    return FacialFeatures(
      symmetry: symmetry,
      faceWidth: faceWidth,
      faceHeight: faceHeight,
      jawlineStrength: jawlineStrength,
      cheekboneProminence: cheekboneProminence,
      foreheadHeight: foreheadHeight,
      facialContours: points,
    );
  }

  static double _calculateSymmetry(List<Point<int>> points) {
    if (points.isEmpty) return 0.0;

    // –ó–Ω–∞—Ö–æ–¥–∏–º–æ —Ü–µ–Ω—Ç—Ä–∞–ª—å–Ω—É –≤–µ—Ä—Ç–∏–∫–∞–ª—å–Ω—É –ª—ñ–Ω—ñ—é
    double centerX =
        points.map((p) => p.x).reduce((a, b) => a + b) / points.length;

    // –†–∞—Ö—É—î–º–æ –≤—ñ–¥—Ö–∏–ª–µ–Ω–Ω—è –≤—ñ–¥ —Å–∏–º–µ—Ç—Ä—ñ—ó
    double totalDeviation = 0;
    int pairs = 0;

    for (int i = 0; i < points.length ~/ 2; i++) {
      Point<int> leftPoint = points[i];
      Point<int> rightPoint = points[points.length - 1 - i];

      double leftDist = (centerX - leftPoint.x).abs();
      double rightDist = (rightPoint.x - centerX).abs();

      totalDeviation += (leftDist - rightDist).abs();
      pairs++;
    }

    // –ù–æ—Ä–º–∞–ª—ñ–∑—É—î–º–æ —Ä–µ–∑—É–ª—å—Ç–∞—Ç –¥–æ –¥—ñ–∞–ø–∞–∑–æ–Ω—É 0-1
    double avgDeviation = totalDeviation / pairs;
    double maxPossibleDeviation = points.map((p) => p.x).reduce(max).toDouble();

    return 1 - (avgDeviation / maxPossibleDeviation);
  }

  static double _analyzeJawline(Face face) {
    final jawContour = face.contours[FaceContourType.lowerLipBottom];
    if (jawContour == null) return 0.5;

    final points = jawContour.points;
    if (points.isEmpty) return 0.5;

    // –ê–Ω–∞–ª—ñ–∑—É—î–º–æ –∫—É—Ç —ñ —á—ñ—Ç–∫—ñ—Å—Ç—å –ª—ñ–Ω—ñ—ó —â–µ–ª–µ–ø–∏
    double angleStrength = _calculateJawlineAngle(points);
    double lineDefinition = _calculateLineDefinition(points);

    return (angleStrength + lineDefinition) / 2;
  }

  static double _analyzeCheekbones(Face face) {
    final leftCheek = face.contours[FaceContourType.leftCheek];
    final rightCheek = face.contours[FaceContourType.rightCheek];

    if (leftCheek == null || rightCheek == null) return 0.5;

    // –ê–Ω–∞–ª—ñ–∑—É—î–º–æ –≤–∏–ø—É–∫–ª—ñ—Å—Ç—å —ñ –ø–æ–ª–æ–∂–µ–Ω–Ω—è –≤–∏–ª–∏—Ü—å
    double cheekboneWidth =
        _calculateCheekboneWidth(leftCheek.points, rightCheek.points);
    double cheekboneHeight =
        _calculateCheekboneHeight(leftCheek.points, rightCheek.points);

    return (cheekboneWidth + cheekboneHeight) / 2;
  }

  static double _analyzeForeheadHeight(Face face) {
    final faceContour = face.contours[FaceContourType.face];
    final noseContour = face.contours[FaceContourType.noseBridge];

    if (faceContour == null || noseContour == null) return 0.5;

    // –í–∏–º—ñ—Ä—é—î–º–æ –≤–∏—Å–æ—Ç—É —á–æ–ª–∞ –≤—ñ–¥–Ω–æ—Å–Ω–æ –∑–∞–≥–∞–ª—å–Ω–æ—ó –≤–∏—Å–æ—Ç–∏ –æ–±–ª–∏—á—á—è
    double totalHeight = face.boundingBox.height;
    double foreheadToNose =
        (noseContour.points.first.y - faceContour.points.first.y).toDouble();

    return foreheadToNose / totalHeight;
  }

  static double _calculateJawlineAngle(List<Point<int>> points) {
    if (points.length < 3) return 0.5;

    Point<int> start = points.first;
    Point<int> end = points.last;

    double angle =
        atan2((end.y - start.y).toDouble(), (end.x - start.x).toDouble());
    return (angle.abs() / pi) * 2; // –ù–æ—Ä–º–∞–ª—ñ–∑—É—î–º–æ –¥–æ 0-1
  }

  static double _calculateLineDefinition(List<Point<int>> points) {
    if (points.length < 2) return 0.5;

    double totalDeviation = 0;
    for (int i = 1; i < points.length; i++) {
      Point<int> prev = points[i - 1];
      Point<int> curr = points[i];

      totalDeviation += sqrt(pow(curr.x - prev.x, 2) + pow(curr.y - prev.y, 2));
    }

    return 1 - (totalDeviation / (points.length * 10)); // –ù–æ—Ä–º–∞–ª—ñ–∑—É—î–º–æ –¥–æ 0-1
  }

  static double _calculateCheekboneWidth(
      List<Point<int>> leftPoints, List<Point<int>> rightPoints) {
    if (leftPoints.isEmpty || rightPoints.isEmpty) return 0.5;

    double leftMax = leftPoints.map((p) => p.x).reduce(min).toDouble();
    double rightMax = rightPoints.map((p) => p.x).reduce(max).toDouble();

    return (rightMax - leftMax) / 100; // –ù–æ—Ä–º–∞–ª—ñ–∑—É—î–º–æ –¥–æ 0-1
  }

  static double _calculateCheekboneHeight(
      List<Point<int>> leftPoints, List<Point<int>> rightPoints) {
    if (leftPoints.isEmpty || rightPoints.isEmpty) return 0.5;

    double leftY =
        leftPoints.map((p) => p.y).reduce((a, b) => a + b) / leftPoints.length;
    double rightY = rightPoints.map((p) => p.y).reduce((a, b) => a + b) /
        rightPoints.length;

    return 1 - (((leftY - rightY).abs()) / 50); // –ù–æ—Ä–º–∞–ª—ñ–∑—É—î–º–æ –¥–æ 0-1
  }
}

[FILE: marinette/lib/app/data/services/recoommendations_service.dart]
import 'package:get/get.dart';
import 'package:marinette/app/data/services/face_shape_analyzer.dart';
import 'package:marinette/app/data/services/color_type_analyzer.dart';

class RecommendationsService {
  static List<String> getMakeupRecommendations(
      FaceShape shape, ColorType colorType) {
    List<String> recommendations = [];
    recommendations.addAll(_getMakeupShapeRecommendations(shape));
    recommendations.addAll(_getMakeupColorRecommendations(colorType));
    return recommendations;
  }

  static List<String> _getMakeupShapeRecommendations(FaceShape shape) {
    switch (shape) {
      case FaceShape.oval:
        return [
          'makeup_shape_oval'.tr,
          'makeup_shape_oval_2'.tr,
          'makeup_shape_oval_3'.tr,
          'makeup_shape_oval_4'.tr,
          'makeup_shape_oval_5'.tr
        ];

      case FaceShape.round:
        return [
          'makeup_shape_round'.tr,
          'makeup_shape_round_2'.tr,
          'makeup_shape_round_3'.tr,
          'makeup_shape_round_4'.tr,
          'makeup_shape_round_5'.tr
        ];

      case FaceShape.square:
        return [
          'makeup_shape_square'.tr,
          'makeup_shape_square_2'.tr,
          'makeup_shape_square_3'.tr,
          'makeup_shape_square_4'.tr,
          'makeup_shape_square_5'.tr
        ];

      case FaceShape.heart:
        return [
          'makeup_shape_heart'.tr,
          'makeup_shape_heart_2'.tr,
          'makeup_shape_heart_3'.tr,
          'makeup_shape_heart_4'.tr,
          'makeup_shape_heart_5'.tr
        ];

      case FaceShape.diamond:
        return [
          'makeup_shape_diamond'.tr,
          'makeup_shape_diamond_2'.tr,
          'makeup_shape_diamond_3'.tr,
          'makeup_shape_diamond_4'.tr,
          'makeup_shape_diamond_5'.tr
        ];

      case FaceShape.rectangle:
        return [
          'makeup_shape_rectangle'.tr,
          'makeup_shape_rectangle_2'.tr,
          'makeup_shape_rectangle_3'.tr,
          'makeup_shape_rectangle_4'.tr,
          'makeup_shape_rectangle_5'.tr
        ];
    }
  }

  static List<String> _getMakeupColorRecommendations(ColorType colorType) {
    switch (colorType) {
      case ColorType.spring:
        return [
          'makeup_color_spring'.tr,
          'makeup_color_spring_2'.tr,
          'makeup_color_spring_3'.tr,
          'makeup_color_spring_4'.tr,
          'makeup_color_spring_5'.tr
        ];

      case ColorType.summer:
        return [
          'makeup_color_summer'.tr,
          'makeup_color_summer_2'.tr,
          'makeup_color_summer_3'.tr,
          'makeup_color_summer_4'.tr,
          'makeup_color_summer_5'.tr
        ];

      case ColorType.autumn:
        return [
          'makeup_color_autumn'.tr,
          'makeup_color_autumn_2'.tr,
          'makeup_color_autumn_3'.tr,
          'makeup_color_autumn_4'.tr,
          'makeup_color_autumn_5'.tr
        ];

      case ColorType.winter:
        return [
          'makeup_color_winter'.tr,
          'makeup_color_winter_2'.tr,
          'makeup_color_winter_3'.tr,
          'makeup_color_winter_4'.tr,
          'makeup_color_winter_5'.tr
        ];
    }
  }

  static List<String> getHairstyleRecommendations(
      FaceShape shape, ColorType colorType) {
    List<String> recommendations = [];
    recommendations.addAll(_getHairstyleShapeRecommendations(shape));
    recommendations.addAll(_getHairColorRecommendations(colorType));
    return recommendations;
  }

  static List<String> _getHairstyleShapeRecommendations(FaceShape shape) {
    switch (shape) {
      case FaceShape.oval:
        return [
          'hairstyle_oval'.tr,
          'hairstyle_oval_2'.tr,
          'hairstyle_oval_3'.tr,
          'hairstyle_oval_4'.tr,
          'hairstyle_oval_5'.tr
        ];

      case FaceShape.round:
        return [
          'hairstyle_round'.tr,
          'hairstyle_round_2'.tr,
          'hairstyle_round_3'.tr,
          'hairstyle_round_4'.tr,
          'hairstyle_round_5'.tr
        ];

      case FaceShape.square:
        return [
          'hairstyle_square'.tr,
          'hairstyle_square_2'.tr,
          'hairstyle_square_3'.tr,
          'hairstyle_square_4'.tr,
          'hairstyle_square_5'.tr
        ];

      case FaceShape.heart:
        return [
          'hairstyle_heart'.tr,
          'hairstyle_heart_2'.tr,
          'hairstyle_heart_3'.tr,
          'hairstyle_heart_4'.tr,
          'hairstyle_heart_5'.tr
        ];

      case FaceShape.diamond:
        return [
          'hairstyle_diamond'.tr,
          'hairstyle_diamond_2'.tr,
          'hairstyle_diamond_3'.tr,
          'hairstyle_diamond_4'.tr,
          'hairstyle_diamond_5'.tr
        ];

      case FaceShape.rectangle:
        return [
          'hairstyle_rectangle'.tr,
          'hairstyle_rectangle_2'.tr,
          'hairstyle_rectangle_3'.tr,
          'hairstyle_rectangle_4'.tr,
          'hairstyle_rectangle_5'.tr
        ];
    }
  }

  static List<String> _getHairColorRecommendations(ColorType colorType) {
    switch (colorType) {
      case ColorType.spring:
        return [
          'haircolor_spring'.tr,
          'haircolor_spring_2'.tr,
          'haircolor_spring_3'.tr
        ];

      case ColorType.summer:
        return [
          'haircolor_summer'.tr,
          'haircolor_summer_2'.tr,
          'haircolor_summer_3'.tr
        ];

      case ColorType.autumn:
        return [
          'haircolor_autumn'.tr,
          'haircolor_autumn_2'.tr,
          'haircolor_autumn_3'.tr
        ];

      case ColorType.winter:
        return [
          'haircolor_winter'.tr,
          'haircolor_winter_2'.tr,
          'haircolor_winter_3'.tr
        ];
    }
  }

  static List<String> getSkincareRecommendations(ColorType colorType) {
    List<String> baseRecommendations = [
      'skincare_recommendation_1'.tr,
      'skincare_recommendation_2'.tr,
      'skincare_recommendation_3'.tr,
      'skincare_recommendation_4'.tr,
      'skincare_recommendation_5'.tr
    ];

    List<String> colorTypeRecommendations =
        _getSkincareColorRecommendations(colorType);

    return [...baseRecommendations, ...colorTypeRecommendations];
  }

  static List<String> _getSkincareColorRecommendations(ColorType type) {
    switch (type) {
      case ColorType.spring:
        return [
          'skincare_spring'.tr,
          'skincare_spring_2'.tr,
          'skincare_spring_3'.tr,
          'skincare_spring_4'.tr,
          'skincare_spring_5'.tr
        ];

      case ColorType.summer:
        return [
          'skincare_summer'.tr,
          'skincare_summer_2'.tr,
          'skincare_summer_3'.tr,
          'skincare_summer_4'.tr,
          'skincare_summer_5'.tr
        ];

      case ColorType.autumn:
        return [
          'skincare_autumn'.tr,
          'skincare_autumn_2'.tr,
          'skincare_autumn_3'.tr,
          'skincare_autumn_4'.tr,
          'skincare_autumn_5'.tr
        ];

      case ColorType.winter:
        return [
          'skincare_winter'.tr,
          'skincare_winter_2'.tr,
          'skincare_winter_3'.tr,
          'skincare_winter_4'.tr,
          'skincare_winter_5'.tr
        ];
    }
  }

  static String getSeasonalRecommendation() {
    final now = DateTime.now();
    final month = now.month;

    // –ó–∏–º–∞ (–≥—Ä—É–¥–µ–Ω—å, —Å—ñ—á–µ–Ω—å, –ª—é—Ç–∏–π)
    if (month == 12 || month == 1 || month == 2) {
      return 'season_winter'.tr;
    }
    // –í–µ—Å–Ω–∞ (–±–µ—Ä–µ–∑–µ–Ω—å, –∫–≤—ñ—Ç–µ–Ω—å, —Ç—Ä–∞–≤–µ–Ω—å)
    else if (month >= 3 && month <= 5) {
      return 'season_spring'.tr;
    }
    // –õ—ñ—Ç–æ (—á–µ—Ä–≤–µ–Ω—å, –ª–∏–ø–µ–Ω—å, —Å–µ—Ä–ø–µ–Ω—å)
    else if (month >= 6 && month <= 8) {
      return 'season_summer'.tr;
    }
    // –û—Å—ñ–Ω—å (–≤–µ—Ä–µ—Å–µ–Ω—å, –∂–æ–≤—Ç–µ–Ω—å, –ª–∏—Å—Ç–æ–ø–∞–¥)
    else {
      return 'season_autumn'.tr;
    }
  }

  static List<String> getPersonalizedTips({
    required FaceShape faceShape,
    required ColorType colorType,
  }) {
    List<String> tips = [];

    // –î–æ–¥–∞—î–º–æ —Å–ø–µ—Ü–∏—Ñ—ñ—á–Ω—ñ –ø–æ—Ä–∞–¥–∏ —â–æ–¥–æ –º–∞–∫—ñ—è–∂—É
    tips.add(_getPersonalizedMakeupTip(faceShape, colorType));

    // –î–æ–¥–∞—î–º–æ –ø–æ—Ä–∞–¥—É —â–æ–¥–æ –¥–æ–≥–ª—è–¥—É –∑–∞ –≤–æ–ª–æ—Å—Å—è–º
    tips.add(_getPersonalizedHairTip(faceShape));

    // –î–æ–¥–∞—î–º–æ —Å–µ–∑–æ–Ω–Ω—É –ø–æ—Ä–∞–¥—É
    tips.add(getSeasonalRecommendation());

    return tips;
  }

  static String _getPersonalizedMakeupTip(
      FaceShape faceShape, ColorType colorType) {
    // –ë–∞–∑–æ–≤–∞ –ø–æ—Ä–∞–¥–∞ —â–æ–¥–æ —Ñ–æ—Ä–º–∏ –æ–±–ª–∏—á—á—è
    String tip = 'personalized_makeup_base'.tr;

    // –î–æ–¥–∞—î–º–æ —Å–ø–µ—Ü–∏—Ñ—ñ–∫—É –¥–ª—è —Ñ–æ—Ä–º–∏ –æ–±–ª–∏—á—á—è
    switch (faceShape) {
      case FaceShape.oval:
        tip += 'personalized_makeup_oval'.tr;
        break;
      case FaceShape.round:
        tip += 'personalized_makeup_round'.tr;
        break;
      case FaceShape.square:
        tip += 'personalized_makeup_square'.tr;
        break;
      case FaceShape.heart:
        tip += 'personalized_makeup_heart'.tr;
        break;
      case FaceShape.diamond:
        tip += 'personalized_makeup_diamond'.tr;
        break;
      case FaceShape.rectangle:
        tip += 'personalized_makeup_rectangle'.tr;
        break;
    }

    // –î–æ–¥–∞—î–º–æ –ø–æ—Ä–∞–¥—É —â–æ–¥–æ –∫–æ–ª—å–æ—Ä–æ—Ç–∏–ø—É
    tip += '. ';
    switch (colorType) {
      case ColorType.spring:
        tip += 'personalized_makeup_spring'.tr;
        break;
      case ColorType.summer:
        tip += 'personalized_makeup_summer'.tr;
        break;
      case ColorType.autumn:
        tip += 'personalized_makeup_autumn'.tr;
        break;
      case ColorType.winter:
        tip += 'personalized_makeup_winter'.tr;
        break;
    }

    return tip;
  }

  static String _getPersonalizedHairTip(FaceShape faceShape) {
    String tip = 'personalized_hair'.tr;

    switch (faceShape) {
      case FaceShape.oval:
        return tip + 'personalized_hair_oval'.tr;
      case FaceShape.round:
        return tip + 'personalized_hair_round'.tr;
      case FaceShape.square:
        return tip + 'personalized_hair_square'.tr;
      case FaceShape.heart:
        return tip + 'personalized_hair_heart'.tr;
      case FaceShape.diamond:
        return tip + 'personalized_hair_diamond'.tr;
      case FaceShape.rectangle:
        return tip + 'personalized_hair_rectangle'.tr;
    }
  }
}

[FILE: marinette/lib/app/data/services/result_saver_service.dart]
import 'dart:io';
import 'dart:convert';
import 'package:path_provider/path_provider.dart';
import 'package:get/get.dart';
import 'package:marinette/app/data/models/face_analysis_result.dart';
import 'package:marinette/app/data/services/user_preferences_service.dart';
import 'package:flutter/foundation.dart' show debugPrint;

class ResultSaverService extends GetxService {
  static const String resultsFolderName = 'analysis_results';
  final RxList<Map<String, dynamic>> _results = <Map<String, dynamic>>[].obs;
  bool _isInitialized = false;
  late final UserPreferencesService _userPrefs;

  Future<ResultSaverService> init() async {
    try {
      if (_isInitialized) return this;

      _userPrefs = Get.find<UserPreferencesService>();
      final userId = _userPrefs.getCurrentUserId();

      final appDir = await getApplicationDocumentsDirectory();
      final resultsDir = Directory('${appDir.path}/$resultsFolderName/$userId');

      if (!await resultsDir.exists()) {
        await resultsDir.create(recursive: true);
      }

      await _loadExistingResults();

      _isInitialized = true;
      debugPrint('ResultSaverService initialized successfully');
    } catch (e) {
      debugPrint('Failed to initialize ResultSaverService: $e');
    }
    return this;
  }

  // –ó–∞–º—ñ–Ω—é—î–º–æ getter –Ω–∞ –∑–≤–∏—á–∞–π–Ω–∏–π –∞—Å–∏–Ω—Ö—Ä–æ–Ω–Ω–∏–π –º–µ—Ç–æ–¥
  Future<String> _getUserResultsPath() async {
    final appDir = await getApplicationDocumentsDirectory();
    final userId = _userPrefs.getCurrentUserId();
    return '${appDir.path}/$resultsFolderName/$userId';
  }

  Future<void> _loadExistingResults() async {
    try {
      final resultsDir = Directory(await _getUserResultsPath());

      if (!await resultsDir.exists()) return;

      final List<FileSystemEntity> files = await resultsDir
          .list()
          .where((entity) => entity.path.endsWith('.json'))
          .toList();

      final List<Map<String, dynamic>> loadedResults = [];

      for (var file in files) {
        try {
          final content = await File(file.path).readAsString();
          final data = json.decode(content) as Map<String, dynamic>;

          final imageFile = File(data['imagePath'] as String);
          if (await imageFile.exists()) {
            loadedResults.add(data);
          } else {
            await file.delete();
          }
        } catch (e) {
          debugPrint('Error reading result file: $e');
          continue;
        }
      }

      loadedResults.sort(
          (a, b) => (b['timestamp'] as int).compareTo(a['timestamp'] as int));

      _results.value = loadedResults;
    } catch (e) {
      debugPrint('Error loading existing results: $e');
    }
  }

  Future<String> saveResult({
    required String imagePath,
    required FaceAnalysisResult result,
  }) async {
    try {
      final resultsDir = Directory(await _getUserResultsPath());

      if (!await resultsDir.exists()) {
        await resultsDir.create(recursive: true);
      }

      final timestamp = DateTime.now().millisecondsSinceEpoch;
      final resultPath = '${resultsDir.path}/result_$timestamp';

      final File imageFile = File(imagePath);
      final String newImagePath = '$resultPath.jpg';
      await imageFile.copy(newImagePath);

      final resultData = {
        'imagePath': newImagePath,
        'faceShape': result.faceShape,
        'colorType': result.colorType,
        'makeupRecommendations': result.makeupRecommendations,
        'hairstyleRecommendations': result.hairstyleRecommendations,
        'skincareRecommendations': result.skincareRecommendations,
        'timestamp': timestamp,
      };

      final File resultFile = File('$resultPath.json');
      await resultFile.writeAsString(json.encode(resultData));

      _results.insert(0, resultData);

      debugPrint('Result saved successfully: $newImagePath');
      return newImagePath;
    } catch (e) {
      debugPrint('Error saving result: $e');
      rethrow;
    }
  }

  Future<List<Map<String, dynamic>>> getAllResults() async {
    if (!_isInitialized) {
      await init();
    }

    await _loadExistingResults();
    return _results;
  }

  Future<void> deleteResult(String imagePath) async {
    try {
      final imageFile = File(imagePath);
      if (await imageFile.exists()) {
        await imageFile.delete();
      }

      final jsonPath = imagePath.replaceAll('.jpg', '.json');
      final resultFile = File(jsonPath);
      if (await resultFile.exists()) {
        await resultFile.delete();
      }

      _results.removeWhere((result) => result['imagePath'] == imagePath);

      debugPrint('Result deleted successfully: $imagePath');
    } catch (e) {
      debugPrint('Error deleting result: $e');
      rethrow;
    }
  }

  Future<void> clearAllResults() async {
    try {
      final resultsDir = Directory(await _getUserResultsPath());
      if (await resultsDir.exists()) {
        await resultsDir.delete(recursive: true);
      }
      _results.clear();
      debugPrint('All results cleared successfully');
    } catch (e) {
      debugPrint('Error clearing results: $e');
      rethrow;
    }
  }
}

[FILE: marinette/lib/app/data/services/skin_color_analyzer.dart]
import 'dart:io';
import 'dart:typed_data';
import 'dart:math' show Point;
import 'package:google_mlkit_face_detection/google_mlkit_face_detection.dart';
import 'package:image/image.dart' as img;

class SkinToneResult {
  final double lightness; // 0-1: –≤—ñ–¥ —Ç–µ–º–Ω–æ–≥–æ –¥–æ —Å–≤—ñ—Ç–ª–æ–≥–æ
  final double warmth; // 0-1: –≤—ñ–¥ —Ö–æ–ª–æ–¥–Ω–æ–≥–æ –¥–æ —Ç–µ–ø–ª–æ–≥–æ
  final double saturation; // 0-1: –≤—ñ–¥ –ø—Ä–∏–≥–ª—É—à–µ–Ω–æ–≥–æ –¥–æ —è—Å–∫—Ä–∞–≤–æ–≥–æ
  final List<int> rgbValues; // [R, G, B]

  SkinToneResult({
    required this.lightness,
    required this.warmth,
    required this.saturation,
    required this.rgbValues,
  });

  @override
  String toString() {
    return 'SkinTone(lightness: $lightness, warmth: $warmth, saturation: $saturation, RGB: $rgbValues)';
  }
}

class SkinColorAnalyzer {
  static Future<SkinToneResult> analyzeSkinTone(
      String imagePath, Face face) async {
    try {
      // –ó–∞–≤–∞–Ω—Ç–∞–∂—É—î–º–æ –∑–æ–±—Ä–∞–∂–µ–Ω–Ω—è
      final File imageFile = File(imagePath);
      final Uint8List bytes = await imageFile.readAsBytes();
      final img.Image? image = img.decodeImage(bytes);

      if (image == null) throw Exception('Failed to decode image');

      // –û—Ç—Ä–∏–º—É—î–º–æ –æ–±–ª–∞—Å—Ç—å –æ–±–ª–∏—á—á—è
      final cheekPoints = _getCheekPoints(face);
      final foreheadPoints = _getForeheadPoints(face);
      final analyzedPoints = [...cheekPoints, ...foreheadPoints];

      // –ê–Ω–∞–ª—ñ–∑—É—î–º–æ –∫–æ–ª—ñ—Ä —É –≤–∏–±—Ä–∞–Ω–∏—Ö —Ç–æ—á–∫–∞—Ö
      List<List<int>> colorSamples = [];
      for (final point in analyzedPoints) {
        if (point.x.round() >= 0 &&
            point.x.round() < image.width &&
            point.y.round() >= 0 &&
            point.y.round() < image.height) {
          final pixel = image.getPixel(point.x.round(), point.y.round());
          colorSamples.add([pixel.r.toInt(), pixel.g.toInt(), pixel.b.toInt()]);
        }
      }

      // –í–∏—Ä–∞—Ö–æ–≤—É—î–º–æ —Å–µ—Ä–µ–¥–Ω—ñ –∑–Ω–∞—á–µ–Ω–Ω—è
      final averageRGB = _calculateAverageRGB(colorSamples);
      final hsv = _rgbToHSV(averageRGB[0], averageRGB[1], averageRGB[2]);

      return SkinToneResult(
        lightness: hsv[2], // V –∑ HSV
        warmth: _calculateWarmth(averageRGB),
        saturation: hsv[1], // S –∑ HSV
        rgbValues: averageRGB,
      );
    } catch (e) {
      rethrow;
    }
  }

  static List<Point<int>> _getCheekPoints(Face face) {
    final leftCheek = face.contours[FaceContourType.leftCheek]?.points ?? [];
    final rightCheek = face.contours[FaceContourType.rightCheek]?.points ?? [];
    return [...leftCheek, ...rightCheek];
  }

  static List<Point<int>> _getForeheadPoints(Face face) {
    final faceContour = face.contours[FaceContourType.face]?.points ?? [];
    if (faceContour.isEmpty) return [];

    // –ë–µ—Ä–µ–º–æ —Ç–æ—á–∫–∏ –∑ –≤–µ—Ä—Ö–Ω—å–æ—ó —Ç—Ä–µ—Ç–∏–Ω–∏ –æ–±–ª–∏—á—á—è
    final topY = faceContour.map((p) => p.y).reduce((a, b) => a < b ? a : b);
    final bottomY = faceContour.map((p) => p.y).reduce((a, b) => a > b ? a : b);
    final foreheadThreshold = topY + (bottomY - topY) ~/ 3;

    return faceContour.where((p) => p.y <= foreheadThreshold).toList();
  }

  static List<int> _calculateAverageRGB(List<List<int>> samples) {
    if (samples.isEmpty) return [0, 0, 0];

    int totalR = 0, totalG = 0, totalB = 0;
    for (final sample in samples) {
      totalR += sample[0];
      totalG += sample[1];
      totalB += sample[2];
    }

    return [
      totalR ~/ samples.length,
      totalG ~/ samples.length,
      totalB ~/ samples.length,
    ];
  }

  static List<double> _rgbToHSV(int r, int g, int b) {
    final rf = r / 255;
    final gf = g / 255;
    final bf = b / 255;

    final cmax = [rf, gf, bf].reduce((a, b) => a > b ? a : b);
    final cmin = [rf, gf, bf].reduce((a, b) => a < b ? a : b);
    final delta = cmax - cmin;

    // –í–∏—Ä–∞—Ö–æ–≤—É—î–º–æ H
    double h = 0;
    if (delta != 0) {
      if (cmax == rf) {
        h = 60 * (((gf - bf) / delta) % 6);
      } else if (cmax == gf) {
        h = 60 * (((bf - rf) / delta) + 2);
      } else {
        h = 60 * (((rf - gf) / delta) + 4);
      }
    }
    if (h < 0) h += 360;

    // –í–∏—Ä–∞—Ö–æ–≤—É—î–º–æ S
    final s = cmax == 0 ? 0.0 : delta / cmax;

    // V –≤–∂–µ –º–∞—î–º–æ (cmax)
    return [h, s, cmax];
  }

  static double _calculateWarmth(List<int> rgb) {
    // –ü–æ—Ä—ñ–≤–Ω—é—î–º–æ –∫—ñ–ª—å–∫—ñ—Å—Ç—å —Ç–µ–ø–ª–∏—Ö (—á–µ—Ä–≤–æ–Ω–∏–π) —ñ —Ö–æ–ª–æ–¥–Ω–∏—Ö (—Å–∏–Ω—ñ–π) —Ç–æ–Ω—ñ–≤
    final redAmount = rgb[0] / 255;
    final blueAmount = rgb[2] / 255;

    // –ù–æ—Ä–º–∞–ª—ñ–∑—É—î–º–æ –¥–æ –¥—ñ–∞–ø–∞–∑–æ–Ω—É 0-1, –¥–µ:
    // 0 - –¥—É–∂–µ —Ö–æ–ª–æ–¥–Ω–∏–π
    // 0.5 - –Ω–µ–π—Ç—Ä–∞–ª—å–Ω–∏–π
    // 1 - –¥—É–∂–µ —Ç–µ–ø–ª–∏–π
    return (redAmount - blueAmount + 1) / 2;
  }
}

[FILE: marinette/lib/app/data/services/user_preferences_service.dart]
import 'package:get/get.dart';
import 'package:hive_flutter/hive_flutter.dart';
import 'package:flutter/foundation.dart' show debugPrint;

class UserPreferencesService extends GetxService {
  static const String _userBoxName = 'user_preferences';
  static const String _userIdKey = 'user_id';

  late Box _box;
  final RxString userId = ''.obs;

  Future<UserPreferencesService> init() async {
    try {
      _box = await Hive.openBox(_userBoxName);
      String? savedUserId = _box.get(_userIdKey);

      if (savedUserId == null) {
        savedUserId = _generateUserId();
        await _box.put(_userIdKey, savedUserId);
      }

      userId.value = savedUserId;
      return this;
    } catch (e) {
      debugPrint('Error initializing UserPreferencesService: $e');
      rethrow;
    }
  }

  String _generateUserId() {
    return DateTime.now().millisecondsSinceEpoch.toString();
  }

  String getCurrentUserId() {
    return userId.value;
  }

  Future<void> setBool(String key, bool value) async {
    try {
      await _box.put(key, value);
    } catch (e) {
      debugPrint('Error setting bool preference: $e');
    }
  }

  Future<bool?> getBool(String key) async {
    try {
      return _box.get(key) as bool?;
    } catch (e) {
      debugPrint('Error getting bool preference: $e');
      return null;
    }
  }

  @override
  void onClose() {
    _box.close();
    super.onClose();
  }
}

[FILE: marinette/lib/app/modules/analysis/analysis_result_screen.dart]
import 'dart:io';
import 'package:flutter/material.dart';
import 'package:get/get.dart';
import 'package:share_plus/share_plus.dart';
import 'package:marinette/app/data/models/face_analysis_result.dart';
import 'package:path_provider/path_provider.dart';

class AnalysisResultScreen extends StatelessWidget {
  final String imagePath;
  final FaceAnalysisResult result;
  final String? heroTag;

  const AnalysisResultScreen({
    super.key,
    required this.imagePath,
    required this.result,
    this.heroTag,
  });

  Future<void> _shareResults() async {
    try {
      final String shareText = '''
üé≠ ${result.faceShape} / ${result.colorType}

üíÑ ${result.makeupRecommendations.map((r) => '‚Ä¢ $r').join('\n')}

üíá‚Äç‚ôÄÔ∏è ${result.hairstyleRecommendations.map((r) => '‚Ä¢ $r').join('\n')}

‚ú® ${result.skincareRecommendations.map((r) => '‚Ä¢ $r').join('\n')}

–ü—Ä–æ–∞–Ω–∞–ª—ñ–∑–æ–≤–∞–Ω–æ –∑–∞ –¥–æ–ø–æ–º–æ–≥–æ—é Beauty Recommendations App
''';

      final tempDir = await getTemporaryDirectory();
      final tempImagePath = '${tempDir.path}/shared_image.jpg';
      await File(imagePath).copy(tempImagePath);

      await Share.shareXFiles(
        [XFile(tempImagePath)],
        text: shareText,
        subject: '–ú–æ—ó –±\'—é—Ç—ñ-—Ä–µ–∫–æ–º–µ–Ω–¥–∞—Ü—ñ—ó',
      );
    } catch (e) {
      Get.snackbar(
        'error'.tr,
        'error_sharing'.tr,
        snackPosition: SnackPosition.BOTTOM,
      );
    }
  }

  @override
  Widget build(BuildContext context) {
    final tag = heroTag ?? imagePath;
    final screenWidth = MediaQuery.of(context).size.width;

    return Scaffold(
      body: Container(
        decoration: const BoxDecoration(
          gradient: LinearGradient(
            begin: Alignment.topCenter,
            end: Alignment.bottomCenter,
            colors: [Color(0xFFFDF2F8), Color(0xFFF5F3FF)],
            stops: [0.0, 1.0],
          ),
        ),
        child: CustomScrollView(
          physics: const BouncingScrollPhysics(),
          slivers: [
            // AppBar
            SliverAppBar(
              expandedHeight: screenWidth,
              floating: false,
              pinned: true,
              flexibleSpace: FlexibleSpaceBar(
                title: Text(
                  'recommendations'.tr,
                  style: const TextStyle(
                    color: Colors.white,
                    fontWeight: FontWeight.bold,
                  ),
                ),
                background: Stack(
                  fit: StackFit.expand,
                  children: [
                    Hero(
                      tag: tag,
                      child: Image.file(
                        File(imagePath),
                        fit: BoxFit.cover,
                      ),
                    ),
                    // Gradient overlay
                    const DecoratedBox(
                      decoration: BoxDecoration(
                        gradient: LinearGradient(
                          begin: Alignment.topCenter,
                          end: Alignment.bottomCenter,
                          colors: [Colors.transparent, Colors.black54],
                        ),
                      ),
                    ),
                  ],
                ),
              ),
              actions: [
                IconButton(
                  icon: const Icon(Icons.share),
                  onPressed: _shareResults,
                ),
              ],
            ),

            // Content
            SliverPadding(
              padding: const EdgeInsets.all(16),
              sliver: SliverList(
                delegate: SliverChildListDelegate([
                  // Type Info Card
                  Card(
                    elevation: 8,
                    shadowColor: Colors.pink.withAlpha(76),
                    shape: RoundedRectangleBorder(
                      borderRadius: BorderRadius.circular(16),
                    ),
                    child: Padding(
                      padding: const EdgeInsets.all(16),
                      child: Row(
                        mainAxisAlignment: MainAxisAlignment.center,
                        children: [
                          _buildTypeInfo('face_shape'.tr, result.faceShape),
                          Container(
                            height: 40,
                            width: 1,
                            color: Colors.grey.withAlpha(50),
                            margin: const EdgeInsets.symmetric(horizontal: 16),
                          ),
                          _buildTypeInfo('color_type'.tr, result.colorType),
                        ],
                      ),
                    ),
                  ),
                  const SizedBox(height: 24),

                  // Makeup Recommendations
                  _buildRecommendationSection(
                    title: 'makeup_recommendations'.tr,
                    recommendations: result.makeupRecommendations,
                    icon: Icons.face,
                    color: Colors.pink,
                  ),
                  const SizedBox(height: 24),

                  // Hairstyle Recommendations
                  _buildRecommendationSection(
                    title: 'hairstyle_recommendations'.tr,
                    recommendations: result.hairstyleRecommendations,
                    icon: Icons.content_cut,
                    color: Colors.purple,
                  ),
                  const SizedBox(height: 24),

                  // Skincare Recommendations
                  _buildRecommendationSection(
                    title: 'skincare_recommendations'.tr,
                    recommendations: result.skincareRecommendations,
                    icon: Icons.spa,
                    color: Colors.pinkAccent,
                  ),
                  const SizedBox(height: 16),
                ]),
              ),
            ),
          ],
        ),
      ),
    );
  }

  Widget _buildTypeInfo(String label, String value) {
    return Expanded(
      child: Column(
        mainAxisSize: MainAxisSize.min,
        children: [
          Text(
            label,
            style: TextStyle(
              color: Colors.grey[600],
              fontSize: 14,
            ),
          ),
          const SizedBox(height: 4),
          Text(
            value,
            style: const TextStyle(
              fontWeight: FontWeight.bold,
              fontSize: 16,
            ),
          ),
        ],
      ),
    );
  }

  Widget _buildRecommendationSection({
    required String title,
    required List<String> recommendations,
    required IconData icon,
    required Color color,
  }) {
    return Card(
      elevation: 8,
      shadowColor: color.withAlpha(76),
      shape: RoundedRectangleBorder(
        borderRadius: BorderRadius.circular(16),
      ),
      child: Padding(
        padding: const EdgeInsets.all(16),
        child: Column(
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            Row(
              children: [
                Container(
                  padding: const EdgeInsets.all(8),
                  decoration: BoxDecoration(
                    color: color.withAlpha(25),
                    borderRadius: BorderRadius.circular(8),
                  ),
                  child: Icon(icon, color: color),
                ),
                const SizedBox(width: 12),
                Text(
                  title,
                  style: const TextStyle(
                    fontSize: 18,
                    fontWeight: FontWeight.bold,
                  ),
                ),
              ],
            ),
            const SizedBox(height: 16),
            ...recommendations.map((recommendation) => Padding(
                  padding: const EdgeInsets.only(bottom: 12),
                  child: Row(
                    crossAxisAlignment: CrossAxisAlignment.start,
                    children: [
                      Container(
                        width: 6,
                        height: 6,
                        margin: const EdgeInsets.only(top: 8, right: 12),
                        decoration: BoxDecoration(
                          color: color,
                          borderRadius: BorderRadius.circular(3),
                        ),
                      ),
                      Expanded(
                        child: Text(
                          recommendation,
                          style: const TextStyle(
                            fontSize: 14,
                            height: 1.5,
                          ),
                        ),
                      ),
                    ],
                  ),
                )),
          ],
        ),
      ),
    );
  }
}

[FILE: marinette/lib/app/modules/analysis/loading_screen.dart]
import 'package:flutter/material.dart';
import 'package:get/get.dart';

class LoadingScreen extends StatelessWidget {
  const LoadingScreen({super.key});

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      backgroundColor: Colors.black54,
      body: Center(
        child: Container(
          padding: const EdgeInsets.all(20),
          decoration: BoxDecoration(
            color: Colors.white,
            borderRadius: BorderRadius.circular(10),
          ),
          child: Column(
            mainAxisSize: MainAxisSize.min,
            children: [
              const CircularProgressIndicator(),
              const SizedBox(height: 20),
              Text(
                'analyzing'.tr,
                style: const TextStyle(
                  fontSize: 16,
                  fontWeight: FontWeight.bold,
                ),
              ),
            ],
          ),
        ),
      ),
    );
  }
}

[FILE: marinette/lib/app/modules/camera/camera_controller.dart]
import 'package:camera/camera.dart';
import 'package:get/get.dart';
import 'package:image_picker/image_picker.dart';
import 'package:permission_handler/permission_handler.dart';
import 'package:flutter/foundation.dart' show debugPrint;
import 'package:flutter/services.dart'; // –î–æ–¥–∞–Ω–æ –¥–ª—è DeviceOrientation

class CustomCameraController extends GetxController {
  final ImagePicker _picker = ImagePicker();
  Rx<CameraController?> cameraController = Rx<CameraController?>(null);
  RxBool isCameraInitialized = false.obs;
  RxBool hasPermission = false.obs;
  RxInt selectedCameraIndex =
      1.obs; // –ü–æ—á–∏–Ω–∞—î–º–æ –∑ —Ñ—Ä–æ–Ω—Ç–∞–ª—å–Ω–æ—ó –∫–∞–º–µ—Ä–∏ (—ñ–Ω–¥–µ–∫—Å 1)
  List<CameraDescription> cameras = [];

  @override
  void onInit() async {
    super.onInit();
    await _checkPermissions();
  }

  @override
  void onClose() {
    cameraController.value?.dispose();
    super.onClose();
  }

  Future<void> _checkPermissions() async {
    try {
      final camera = await Permission.camera.status;
      if (camera.isGranted) {
        hasPermission.value = true;
        await _initializeCamera();
      } else {
        final result = await Permission.camera.request();
        hasPermission.value = result.isGranted;
        if (result.isGranted) {
          await _initializeCamera();
        }
      }
    } catch (e) {
      debugPrint('Error checking permissions: $e');
      Get.snackbar('error'.tr, 'error_camera'.tr);
    }
  }

  Future<void> _initializeCamera() async {
    try {
      cameras = await availableCameras();
      if (cameras.isEmpty) {
        debugPrint('No cameras available');
        return;
      }

      // –ü–µ—Ä–µ–∫–æ–Ω—É—î–º–æ—Å—è, —â–æ —ñ–Ω–¥–µ–∫—Å –≤ –º–µ–∂–∞—Ö –¥–æ—Å—Ç—É–ø–Ω–∏—Ö –∫–∞–º–µ—Ä
      if (selectedCameraIndex.value >= cameras.length) {
        selectedCameraIndex.value = 0;
      }

      final controller = CameraController(
        cameras[selectedCameraIndex.value],
        ResolutionPreset.high,
        enableAudio: false,
        imageFormatGroup: ImageFormatGroup.jpeg,
      );

      await controller.initialize();

      // –í—Å—Ç–∞–Ω–æ–≤–ª—é—î–º–æ –ø—Ä–∞–≤–∏–ª—å–Ω—É –æ—Ä—ñ—î–Ω—Ç–∞—Ü—ñ—é
      await controller.lockCaptureOrientation(DeviceOrientation.portraitUp);

      cameraController.value = controller;
      isCameraInitialized.value = true;
    } catch (e) {
      debugPrint('Error initializing camera: $e');
      Get.snackbar('error'.tr, 'error_camera'.tr);
    }
  }

  Future<void> switchCamera() async {
    if (cameras.length < 2) return;

    selectedCameraIndex.value = selectedCameraIndex.value == 0 ? 1 : 0;

    // Dispose –ø–æ—Ç–æ—á–Ω–æ–≥–æ –∫–æ–Ω—Ç—Ä–æ–ª–µ—Ä–∞
    await cameraController.value?.dispose();

    isCameraInitialized.value = false;
    await _initializeCamera();
  }

  Future<String?> takePhoto() async {
    try {
      if (!isCameraInitialized.value || cameraController.value == null) {
        debugPrint('Camera not initialized');
        return null;
      }

      final XFile image = await cameraController.value!.takePicture();
      debugPrint('Photo taken: ${image.path}');
      return image.path;
    } catch (e) {
      debugPrint('Error taking photo: $e');
      Get.snackbar('error'.tr, 'error_camera'.tr);
      return null;
    }
  }

  Future<String?> pickFromGallery() async {
    try {
      final XFile? image = await _picker.pickImage(
        source: ImageSource.gallery,
        imageQuality: 80,
      );
      debugPrint('Image picked: ${image?.path}');
      return image?.path;
    } catch (e) {
      debugPrint('Error picking image: $e');
      Get.snackbar('error'.tr, 'Could not pick image from gallery'.tr);
      return null;
    }
  }
}

[FILE: marinette/lib/app/modules/camera/camera_screen.dart]
import 'package:flutter/material.dart';
import 'package:get/get.dart';
import 'package:camera/camera.dart';
import 'camera_controller.dart';

class CameraScreen extends GetView<CustomCameraController> {
  const CameraScreen({super.key});

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      backgroundColor: Colors.black,
      body: SafeArea(
        child: Stack(
          children: [
            // Camera Preview
            Obx(() {
              if (!controller.isCameraInitialized.value) {
                return const Center(child: CircularProgressIndicator());
              }
              return Center(
                child: Transform.rotate(
                  angle: 0, // –ü—Ä–∏–±–∏—Ä–∞—î–º–æ –ø–æ–≤–æ—Ä–æ—Ç
                  child: CameraPreview(controller.cameraController.value!),
                ),
              );
            }),

            // Controls overlay
            Positioned(
              bottom: 30,
              left: 0,
              right: 0,
              child: Row(
                mainAxisAlignment: MainAxisAlignment.spaceEvenly,
                children: [
                  // –ö–Ω–æ–ø–∫–∞ –ø–µ—Ä–µ–∫–ª—é—á–µ–Ω–Ω—è –∫–∞–º–µ—Ä–∏
                  FloatingActionButton(
                    heroTag: 'switch_camera',
                    backgroundColor: Colors.white38,
                    onPressed: controller.switchCamera,
                    child: const Icon(Icons.flip_camera_ios),
                  ),
                  // –ö–Ω–æ–ø–∫–∞ –∑–π–æ–º–∫–∏
                  FloatingActionButton(
                    heroTag: 'capture',
                    backgroundColor: Colors.white,
                    onPressed: () async {
                      final imagePath = await controller.takePhoto();
                      if (imagePath != null) {
                        Get.back(result: imagePath);
                      }
                    },
                    child: const Icon(Icons.camera_alt, color: Colors.black),
                  ),
                  // –î–æ–¥–∞—î–º–æ –ø—É—Å—Ç–∏–π –∫–æ–Ω—Ç–µ–π–Ω–µ—Ä –¥–ª—è —Å–∏–º–µ—Ç—Ä—ñ—ó
                  const SizedBox(width: 56), // –®–∏—Ä–∏–Ω–∞ FloatingActionButton
                ],
              ),
            ),
          ],
        ),
      ),
    );
  }
}

[FILE: marinette/lib/app/modules/history/history_screen.dart]
import 'dart:io';
import 'package:flutter/material.dart';
import 'package:get/get.dart';
import 'package:marinette/app/data/models/face_analysis_result.dart';
import 'package:marinette/app/data/services/result_saver_service.dart';
import 'package:marinette/app/modules/analysis/analysis_result_screen.dart';
import 'package:intl/intl.dart';
import 'package:flutter/foundation.dart' show debugPrint;

class HistoryScreen extends StatelessWidget {
  final ResultSaverService _saverService = Get.find<ResultSaverService>();
  final RxBool _isLoading = false.obs;

  HistoryScreen({super.key});

  Future<void> _refreshResults() async {
    debugPrint('Refreshing history results');
    _isLoading.value = true;
    try {
      await _saverService.getAllResults();
    } catch (e) {
      debugPrint('Error refreshing results: $e');
      Get.snackbar(
        'error'.tr,
        'error_loading_results'.tr,
        snackPosition: SnackPosition.BOTTOM,
      );
    } finally {
      _isLoading.value = false;
    }
  }

  void _openResult(Map<String, dynamic> resultData) {
    debugPrint('Opening result details');
    final result = FaceAnalysisResult(
      faceShape: resultData['faceShape'],
      colorType: resultData['colorType'],
      makeupRecommendations:
          List<String>.from(resultData['makeupRecommendations']),
      hairstyleRecommendations:
          List<String>.from(resultData['hairstyleRecommendations']),
      skincareRecommendations:
          List<String>.from(resultData['skincareRecommendations']),
    );

    Get.to(() => AnalysisResultScreen(
          imagePath: resultData['imagePath'],
          result: result,
        ));
  }

  Future<void> _deleteResult(String imagePath) async {
    debugPrint('Deleting result: $imagePath');
    try {
      await _saverService.deleteResult(imagePath);
      Get.snackbar(
        'info'.tr,
        '–†–µ–∑—É–ª—å—Ç–∞—Ç –≤–∏–¥–∞–ª–µ–Ω–æ —É—Å–ø—ñ—à–Ω–æ',
        snackPosition: SnackPosition.BOTTOM,
      );
    } catch (e) {
      debugPrint('Error deleting result: $e');
      Get.snackbar(
        'error'.tr,
        'error_deleting_result'.tr,
        snackPosition: SnackPosition.BOTTOM,
      );
    }
  }

  @override
  Widget build(BuildContext context) {
    debugPrint('Building HistoryScreen');
    // –ü—Ä–∏ —Å—Ç–≤–æ—Ä–µ–Ω–Ω—ñ –µ–∫—Ä–∞–Ω—É –æ–Ω–æ–≤–ª—é—î–º–æ –¥–∞–Ω—ñ
    _refreshResults();

    return Scaffold(
      appBar: AppBar(
        title: Text('history'.tr),
        actions: [
          IconButton(
            icon: const Icon(Icons.refresh),
            onPressed: _refreshResults,
          ),
        ],
      ),
      body: Obx(() {
        if (_isLoading.value) {
          return const Center(child: CircularProgressIndicator());
        }

        return FutureBuilder<List<Map<String, dynamic>>>(
          future: _saverService.getAllResults(),
          builder: (context, snapshot) {
            debugPrint(
                'Building FutureBuilder with state: ${snapshot.connectionState}');

            if (snapshot.connectionState == ConnectionState.waiting) {
              return const Center(child: CircularProgressIndicator());
            }

            if (snapshot.hasError) {
              debugPrint('Error loading history: ${snapshot.error}');
              return Center(
                child: Column(
                  mainAxisAlignment: MainAxisAlignment.center,
                  children: [
                    const Icon(
                      Icons.error_outline,
                      size: 64,
                      color: Colors.red,
                    ),
                    const SizedBox(height: 16),
                    Text(
                      'error_loading_results'.tr,
                      style: const TextStyle(
                        fontSize: 18,
                        color: Colors.grey,
                      ),
                    ),
                  ],
                ),
              );
            }

            if (!snapshot.hasData || snapshot.data!.isEmpty) {
              debugPrint('No history data available');
              return Center(
                child: Column(
                  mainAxisAlignment: MainAxisAlignment.center,
                  children: [
                    const Icon(
                      Icons.history,
                      size: 64,
                      color: Colors.grey,
                    ),
                    const SizedBox(height: 16),
                    Text(
                      'no_history'.tr,
                      style: const TextStyle(
                        fontSize: 18,
                        color: Colors.grey,
                      ),
                    ),
                  ],
                ),
              );
            }

            debugPrint(
                'Building history list with ${snapshot.data!.length} items');
            return RefreshIndicator(
              onRefresh: _refreshResults,
              child: ListView.builder(
                padding: const EdgeInsets.all(8),
                itemCount: snapshot.data!.length,
                itemBuilder: (context, index) {
                  final result = snapshot.data![index];
                  debugPrint('Building history item $index');

                  final DateTime date = DateTime.fromMillisecondsSinceEpoch(
                    result['timestamp'] as int,
                  );
                  final String formattedDate =
                      DateFormat('dd.MM.yyyy HH:mm').format(date);

                  return Dismissible(
                    key: Key(result['imagePath']),
                    background: Container(
                      color: Colors.red,
                      alignment: Alignment.centerRight,
                      padding: const EdgeInsets.only(right: 16),
                      child: const Icon(
                        Icons.delete,
                        color: Colors.white,
                      ),
                    ),
                    direction: DismissDirection.endToStart,
                    confirmDismiss: (direction) async {
                      return await Get.dialog<bool>(
                            AlertDialog(
                              title: Text('confirm_delete'.tr),
                              content: Text('delete_result_confirmation'.tr),
                              actions: [
                                TextButton(
                                  onPressed: () => Get.back(result: false),
                                  child: Text('cancel'.tr),
                                ),
                                TextButton(
                                  onPressed: () => Get.back(result: true),
                                  child: Text(
                                    'delete'.tr,
                                    style: const TextStyle(color: Colors.red),
                                  ),
                                ),
                              ],
                            ),
                          ) ??
                          false;
                    },
                    onDismissed: (direction) {
                      _deleteResult(result['imagePath']);
                    },
                    child: Card(
                      margin: const EdgeInsets.only(bottom: 12),
                      elevation: 4,
                      child: InkWell(
                        onTap: () => _openResult(result),
                        child: Column(
                          crossAxisAlignment: CrossAxisAlignment.start,
                          children: [
                            // –ó–æ–±—Ä–∞–∂–µ–Ω–Ω—è
                            if (result['imagePath'] != null)
                              SizedBox(
                                width: double.infinity,
                                height: 200,
                                child: ClipRRect(
                                  borderRadius: const BorderRadius.vertical(
                                    top: Radius.circular(4),
                                  ),
                                  child: Image.file(
                                    File(result['imagePath']),
                                    fit: BoxFit.cover,
                                    errorBuilder: (context, error, stackTrace) {
                                      debugPrint('Error loading image: $error');
                                      return Container(
                                        color: Colors.grey[200],
                                        child: const Icon(
                                          Icons.broken_image,
                                          size: 64,
                                          color: Colors.grey,
                                        ),
                                      );
                                    },
                                  ),
                                ),
                              ),

                            // –Ü–Ω—Ñ–æ—Ä–º–∞—Ü—ñ—è
                            Padding(
                              padding: const EdgeInsets.all(16),
                              child: Column(
                                crossAxisAlignment: CrossAxisAlignment.start,
                                children: [
                                  Row(
                                    mainAxisAlignment:
                                        MainAxisAlignment.spaceBetween,
                                    children: [
                                      Text(
                                        formattedDate,
                                        style: TextStyle(
                                          color: Colors.grey[600],
                                          fontSize: 14,
                                        ),
                                      ),
                                      IconButton(
                                        icon: const Icon(Icons.delete_outline),
                                        onPressed: () =>
                                            _deleteResult(result['imagePath']),
                                      ),
                                    ],
                                  ),
                                  const SizedBox(height: 8),
                                  Text(
                                    '${result['faceShape']} / ${result['colorType']}',
                                    style: const TextStyle(
                                      fontSize: 18,
                                      fontWeight: FontWeight.bold,
                                    ),
                                  ),
                                  const SizedBox(height: 4),
                                  Row(
                                    children: [
                                      Icon(
                                        Icons.tips_and_updates_outlined,
                                        size: 16,
                                        color: Colors.grey[600],
                                      ),
                                      const SizedBox(width: 4),
                                      Text(
                                        '${(result['makeupRecommendations'] as List).length + (result['hairstyleRecommendations'] as List).length + (result['skincareRecommendations'] as List).length} —Ä–µ–∫–æ–º–µ–Ω–¥–∞—Ü—ñ–π',
                                        style: TextStyle(
                                          color: Colors.grey[600],
                                          fontSize: 14,
                                        ),
                                      ),
                                    ],
                                  ),
                                ],
                              ),
                            ),
                          ],
                        ),
                      ),
                    ),
                  );
                },
              ),
            );
          },
        );
      }),
    );
  }
}

[FILE: marinette/lib/app/modules/home/home_screen.dart]
import 'package:flutter/material.dart';
import 'package:get/get.dart';
import 'package:marinette/app/data/services/face_analysis_service.dart';
import 'package:marinette/app/data/services/result_saver_service.dart';
import 'package:marinette/app/data/services/content_service.dart';
import 'package:marinette/config/translations/app_translations.dart';
import 'package:marinette/app/modules/analysis/analysis_result_screen.dart';
import 'package:marinette/app/modules/camera/camera_controller.dart';
import 'package:marinette/app/modules/camera/camera_screen.dart';
import 'package:marinette/app/modules/history/history_screen.dart';
import 'package:marinette/app/core/widgets/wave_background_painter.dart';

class HomeScreen extends StatelessWidget {
  const HomeScreen({super.key});

  void _changeLanguage() {
    final service = Get.find<LocalizationService>();
    final newLocale = service.getCurrentLocale() == 'en' ? 'uk' : 'en';
    service.changeLocale(newLocale);
  }

  Future<void> _processImage(String? imagePath) async {
    if (imagePath != null) {
      try {
        debugPrint('Starting image processing for path: $imagePath');

        Get.dialog(
          PopScope(
            canPop: false,
            child: const Center(child: CircularProgressIndicator()),
          ),
          barrierDismissible: false,
        );

        final analysisService = Get.put(FaceAnalysisService());
        final result = await analysisService.analyzeFace(imagePath);

        if (Get.isDialogOpen ?? false) {
          Get.back();
        }

        if (result != null) {
          debugPrint('Saving result to history');
          try {
            final resultSaverService = Get.find<ResultSaverService>();
            await resultSaverService.saveResult(
              imagePath: imagePath,
              result: result,
            );
            debugPrint('Result saved successfully');
          } catch (e) {
            debugPrint('Error saving result: $e');
            Get.snackbar(
              'error'.tr,
              'error_saving_result'.tr,
              snackPosition: SnackPosition.BOTTOM,
            );
          }

          await Get.to(() => AnalysisResultScreen(
                imagePath: imagePath,
                result: result,
              ));
        } else {
          Get.snackbar(
            'error'.tr,
            'analysis_failed'.tr,
            snackPosition: SnackPosition.BOTTOM,
          );
        }
      } catch (e) {
        debugPrint('Error during image processing: $e');
        if (Get.isDialogOpen ?? false) {
          Get.back();
        }
        Get.snackbar(
          'error'.tr,
          'analysis_failed'.tr,
          snackPosition: SnackPosition.BOTTOM,
        );
      }
    }
  }

  @override
  Widget build(BuildContext context) {
    final contentService = Get.find<ContentService>();
    final screenHeight = MediaQuery.of(context).size.height;

    return Scaffold(
      appBar: AppBar(
        title: Text('app_name'.tr),
        actions: [
          IconButton(
            icon: const Icon(Icons.history),
            onPressed: () => Get.to(() => HistoryScreen()),
          ),
          IconButton(
            icon: const Icon(Icons.language),
            onPressed: _changeLanguage,
          ),
        ],
      ),
      body: Container(
        height: screenHeight,
        decoration: const BoxDecoration(
          gradient: LinearGradient(
            begin: Alignment.topCenter,
            end: Alignment.bottomCenter,
            colors: [Color(0xFFFDF2F8), Color(0xFFF5F3FF)],
            stops: [0.0, 1.0],
          ),
        ),
        child: Stack(
          fit: StackFit.expand,
          children: [
            Positioned.fill(
              child: CustomPaint(
                painter: WaveBackgroundPainter(),
              ),
            ),
            SafeArea(
              child: SingleChildScrollView(
                physics: const AlwaysScrollableScrollPhysics(),
                child: Padding(
                  padding: const EdgeInsets.all(24.0),
                  child: Column(
                    crossAxisAlignment: CrossAxisAlignment.stretch,
                    children: [
                      _buildFeatureCard(
                        title: 'take_photo'.tr,
                        subtitle: 'Get instant beauty analysis',
                        icon: Icons.camera_alt,
                        onTap: () async {
                          Get.lazyPut(() => CustomCameraController());
                          final imagePath =
                              await Get.to<String>(() => const CameraScreen());
                          await _processImage(imagePath);
                        },
                      ),
                      const SizedBox(height: 16),
                      _buildFeatureCard(
                        title: 'choose_from_gallery'.tr,
                        subtitle: 'Use existing photo',
                        icon: Icons.photo_library,
                        onTap: () async {
                          final controller = Get.put(CustomCameraController());
                          final imagePath = await controller.pickFromGallery();
                          await _processImage(imagePath);
                        },
                      ),
                      const SizedBox(height: 16),
                      _buildFeatureCard(
                        title: 'Beauty Hub',
                        subtitle: 'Articles, guides and tips',
                        icon: Icons.menu_book,
                        onTap: () {
                          Get.snackbar(
                            'info'.tr,
                            'Coming soon!',
                            snackPosition: SnackPosition.BOTTOM,
                          );
                        },
                      ),
                      const SizedBox(height: 24),
                      _buildTipOfTheDay(contentService),
                      const SizedBox(height: 24),
                      _buildTrendsCarousel(contentService),
                      const SizedBox(height: 24),
                    ],
                  ),
                ),
              ),
            ),
          ],
        ),
      ),
    );
  }

  Widget _buildFeatureCard({
    required String title,
    required String subtitle,
    required IconData icon,
    required VoidCallback onTap,
  }) {
    return Card(
      elevation: 8,
      shadowColor: Colors.pink.withAlpha(76),
      shape: RoundedRectangleBorder(
        borderRadius: BorderRadius.circular(20),
      ),
      child: InkWell(
        onTap: onTap,
        borderRadius: BorderRadius.circular(20),
        child: Container(
          padding: const EdgeInsets.all(20),
          decoration: BoxDecoration(
            borderRadius: BorderRadius.circular(20),
            gradient: LinearGradient(
              begin: Alignment.topLeft,
              end: Alignment.bottomRight,
              colors: [
                Colors.white,
                Colors.grey.shade50,
              ],
            ),
          ),
          child: Row(
            children: [
              Expanded(
                child: Column(
                  crossAxisAlignment: CrossAxisAlignment.start,
                  children: [
                    Text(
                      title,
                      style: const TextStyle(
                        fontSize: 20,
                        fontWeight: FontWeight.bold,
                      ),
                    ),
                    const SizedBox(height: 8),
                    Text(
                      subtitle,
                      style: TextStyle(
                        color: Colors.grey[600],
                        fontSize: 14,
                      ),
                    ),
                  ],
                ),
              ),
              Container(
                padding: const EdgeInsets.all(12),
                decoration: BoxDecoration(
                  color: Colors.pink.withAlpha(25),
                  borderRadius: BorderRadius.circular(12),
                ),
                child: Icon(
                  icon,
                  size: 32,
                  color: Colors.pink,
                ),
              ),
            ],
          ),
        ),
      ),
    );
  }

  Widget _buildTipOfTheDay(ContentService contentService) {
    return Obx(() {
      final tip = contentService.currentTip.value;
      return Container(
        padding: const EdgeInsets.all(20),
        decoration: BoxDecoration(
          gradient: const LinearGradient(
            begin: Alignment.topLeft,
            end: Alignment.bottomRight,
            colors: [Colors.pink, Colors.purple],
          ),
          borderRadius: BorderRadius.circular(20),
          boxShadow: [
            BoxShadow(
              color: Colors.pink.withAlpha(76),
              blurRadius: 8,
              offset: const Offset(0, 4),
            ),
          ],
        ),
        child: Column(
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            Row(
              children: [
                Text(
                  tip.icon,
                  style: const TextStyle(
                    fontSize: 24,
                  ),
                ),
                const SizedBox(width: 8),
                const Text(
                  'Tip of the Day',
                  style: TextStyle(
                    color: Colors.white,
                    fontSize: 18,
                    fontWeight: FontWeight.bold,
                  ),
                ),
              ],
            ),
            const SizedBox(height: 12),
            Text(
              tip.tip,
              style: const TextStyle(
                color: Colors.white,
                fontSize: 14,
              ),
            ),
          ],
        ),
      );
    });
  }

  Widget _buildTrendsCarousel(ContentService contentService) {
    return Obx(() {
      final trends = contentService.currentTrends;
      return Column(
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          const Row(
            children: [
              Icon(
                Icons.trending_up,
                color: Colors.pink,
                size: 24,
              ),
              SizedBox(width: 8),
              Text(
                'Season Trends',
                style: TextStyle(
                  fontSize: 18,
                  fontWeight: FontWeight.bold,
                ),
              ),
            ],
          ),
          const SizedBox(height: 16),
          SingleChildScrollView(
            scrollDirection: Axis.horizontal,
            physics: const BouncingScrollPhysics(),
            child: Row(
              children: trends
                  .map((trend) => Padding(
                        padding: const EdgeInsets.only(right: 16),
                        child: _buildTrendCard(
                          title: trend.title,
                          description: trend.description,
                        ),
                      ))
                  .toList(),
            ),
          ),
        ],
      );
    });
  }

  Widget _buildTrendCard({required String title, required String description}) {
    return Container(
      width: 250,
      padding: const EdgeInsets.all(16),
      decoration: BoxDecoration(
        color: Colors.white,
        borderRadius: BorderRadius.circular(16),
        boxShadow: [
          BoxShadow(
            color: Colors.pink.withAlpha(25),
            blurRadius: 8,
            offset: const Offset(0, 4),
          ),
        ],
      ),
      child: Column(
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          Text(
            title,
            style: const TextStyle(
              fontSize: 16,
              fontWeight: FontWeight.bold,
            ),
          ),
          const SizedBox(height: 8),
          Text(
            description,
            style: TextStyle(
              color: Colors.grey[600],
              fontSize: 14,
            ),
          ),
        ],
      ),
    );
  }
}

[FILE: marinette/lib/app/modules/shared/hero_photo_view.dart]
import 'dart:io';
import 'package:flutter/material.dart';
import 'package:get/get.dart';

class HeroPhotoView extends StatelessWidget {
  final String imagePath;
  final String heroTag;

  const HeroPhotoView({
    required this.imagePath,
    required this.heroTag,
    super.key,
  });

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      backgroundColor: Colors.black,
      body: GestureDetector(
        onTap: () => Get.back(),
        child: Stack(
          children: [
            Center(
              child: Hero(
                tag: heroTag,
                child: InteractiveViewer(
                  minScale: 0.5,
                  maxScale: 4.0,
                  child: Image.file(
                    File(imagePath),
                    fit: BoxFit.contain,
                  ),
                ),
              ),
            ),
            SafeArea(
              child: Padding(
                padding: const EdgeInsets.all(8.0),
                child: IconButton(
                  icon: const Icon(
                    Icons.close,
                    color: Colors.white,
                    size: 30,
                  ),
                  onPressed: () => Get.back(),
                ),
              ),
            ),
          ],
        ),
      ),
    );
  }
}

[FILE: marinette/lib/config/translations/app_translations.dart]
import 'dart:convert';
import 'package:flutter/material.dart';
import 'package:flutter/services.dart';
import 'package:get/get.dart';

class AppTranslations extends Translations {
  @override
  Map<String, Map<String, String>> get keys => {};
}

class LocalizationService extends GetxService {
  final RxString currentLocale = 'uk'.obs;
  final Map<String, Map<String, String>> translations = {};

  Future<LocalizationService> init() async {
    try {
      await loadTranslations();
      return this;
    } catch (e) {
      print('Error initializing LocalizationService: $e');
      return this;
    }
  }

  Future<void> loadTranslations() async {
    try {
      final en = await rootBundle.loadString('assets/i18n/en.json');
      final uk = await rootBundle.loadString('assets/i18n/uk.json');

      translations['en'] = Map<String, String>.from(json.decode(en));
      translations['uk'] = Map<String, String>.from(json.decode(uk));

      Get.addTranslations(translations);
    } catch (e) {
      print('Error loading translations: $e');
    }
  }

  void changeLocale(String locale) {
    if (locale == currentLocale.value) return;

    currentLocale.value = locale;
    Get.updateLocale(Locale(locale));
  }

  String getCurrentLocale() => currentLocale.value;
}

[FILE: marinette/lib/main.dart]
import 'package:flutter/material.dart';
import 'package:get/get.dart';
import 'package:flutter_localizations/flutter_localizations.dart';
import 'package:hive_flutter/hive_flutter.dart';
import 'package:marinette/app/modules/home/home_screen.dart';
import 'package:marinette/app/core/theme/app_theme.dart';
import 'package:marinette/app/data/services/result_saver_service.dart';
import 'package:marinette/app/data/services/user_preferences_service.dart';
import 'package:marinette/app/data/services/audio_service.dart';
import 'package:marinette/app/data/services/content_service.dart';
import 'package:marinette/config/translations/app_translations.dart';

void main() async {
  try {
    WidgetsFlutterBinding.ensureInitialized();

    // Initialize Hive
    await Hive.initFlutter();

    // Initialize essential services
    await Get.putAsync(() => LocalizationService().init());
    await Get.putAsync(() => UserPreferencesService().init());
    await Get.putAsync(() => ResultSaverService().init());
    await Get.putAsync(() => ContentService().init());

    // Initialize audio service in the background
    initAudioService();

    runApp(const BeautyRecommendationsApp());
  } catch (e) {
    debugPrint('Error during app initialization: $e');
    runApp(MaterialApp(
      home: Scaffold(
        body: Center(
          child: Text('Error initializing app: $e'),
        ),
      ),
    ));
  }
}

void initAudioService() {
  Future.delayed(const Duration(seconds: 2), () async {
    try {
      debugPrint('Starting audio service initialization');
      await Get.putAsync(
        () => AudioService().init(),
        permanent: true,
      );
      debugPrint('Audio service initialized successfully');
    } catch (e) {
      debugPrint('Failed to initialize audio service: $e');
    }
  });
}

class BeautyRecommendationsApp extends StatelessWidget {
  const BeautyRecommendationsApp({super.key});

  @override
  Widget build(BuildContext context) {
    return GetMaterialApp(
      title: 'Beauty Recommendations',
      theme: AppTheme.theme,
      translations: AppTranslations(),
      locale: const Locale('uk'),
      fallbackLocale: const Locale('en'),
      localizationsDelegates: const [
        GlobalMaterialLocalizations.delegate,
        GlobalWidgetsLocalizations.delegate,
        GlobalCupertinoLocalizations.delegate,
      ],
      supportedLocales: const [
        Locale('en'),
        Locale('uk'),
      ],
      home: const HomeScreen(),
    );
  }
}

[FILE: marinette/pubspec.yaml]
name: marinette
description: A mobile app for beauty recommendations based on facial features analysis.
publish_to: 'none'
version: 1.0.0+1

environment:
  sdk: '>=3.0.0 <4.0.0'

dependencies:
  flutter:
    sdk: flutter
  flutter_localizations:
    sdk: flutter
  
  # State Management
  get: ^4.6.5
  
  # Local Storage
  hive: ^2.2.3
  hive_flutter: ^1.1.0
  
  # Image Processing & ML
  google_mlkit_face_detection: ^0.12.0
  camera: ^0.11.0+2
  image_picker: ^1.0.4
  image: ^4.1.3
  
  # Audio
  just_audio: ^0.9.36
  audio_session: ^0.1.18
  
  # Utils
  path_provider: ^2.0.15
  permission_handler: ^11.3.1
  intl: ^0.19.0
  share_plus: ^7.2.1

dev_dependencies:
  flutter_test:
    sdk: flutter
  flutter_lints: ^5.0.0
  build_runner: ^2.4.6
  hive_generator: ^2.0.0

flutter:
  uses-material-design: true
  
  assets:
    - assets/i18n/
    - assets/i18n/en.json
    - assets/i18n/uk.json
    - assets/audio/
    - assets/audio/nana.mp3
    
  fonts:
    - family: PlayfairDisplay
      fonts:
        - asset: assets/fonts/PlayfairDisplay-Regular.ttf
        - asset: assets/fonts/PlayfairDisplay-Bold.ttf
          weight: 700
        - asset: assets/fonts/PlayfairDisplay-Italic.ttf
          style: italic
